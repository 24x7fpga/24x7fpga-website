+++
title = "Synchronous and Asynchronous Reset"
author = ["Kiran"]
date = 2024-07-25T11:34:00-04:00
tags = ["rtl"]
draft = false
css = "../../zcustom.css"
+++

[Design](https://github.com/24x7fpga/iVerilog/blob/master/design/asyn_rst/asyn_rst.v) -- [Testbench](https://github.com/24x7fpga/iVerilog/blob/master/tb_design/tb_asyn_rst/tb_asyn_rst.v) -- [RTL Design Directory]({{< relref "2024_06_05_00_21_53_rtl_design_directory.md" >}})


## Synchronous and Asynchronous Reset {#synchronous-and-asynchronous-reset}

Resets are crucial in digital circuits for ensuring the system starts from a known state.

-   Resets allow the system to recover from errors by reinitializing the state.
-   Resets ensure that all flip-flops start from a known state.

There are two types of resets based on the reset activation and they are:

1.  Synchronous Reset
2.  Asynchronous Reset


### Synchronous Reset {#synchronous-reset}

In synchronous reset circuits, the reset signal is synchronized with the clock. When the reset is applied, the action only occurs at clock edges (positive or negative edge), avoiding glitches and metastability. The coding style to model synchronous reset is an **if/else** priority style with reset in the **if** condition and all the other logic in the **else** section. This type of logic will be implemented as shown in the figure below:

{{< figure src="/ox-hugo/syn_rst.svg" caption="<span class=\"figure-number\">Figure 1: </span>Synchronous Reset Implementation" class="center !important" width="400px" >}}

The input signal is **ANDED** with the reset signal before reaching the register. In some implementations, a **MUX** will be implemented in place of an AND where the reset is the select input, one of the inputs is tied to the ground, and the other to set to the input.


#### Example {#example}

```verilog
module syn_rst(clk, rst, d, q);
  // outputs
   output q;
   // inputs
   input d;
   input clk;
   input rst;

always_ff@(posedge clk)
  if(!rst)
    q <= 1'b0;
  else
    q <= d;

endmodule
```


#### Advantages {#advantages}

1.  Synchronous reset ensures the entire circuit is synchronous all the time.
2.  Synchronous resert ensures the reset actions occur at the clock edges, preventing the flip-flop from going into metastability.
3.  When the reset is generated by an internal condition, synchronous resets are advisable to be implemented as they filter out any glitches.
4.  Working


#### Disadvantages {#disadvantages}

1.  The reset signal should be applied long enough so that the clock edge samples the reset signal.
2.  A pulse stretcher should be implemented to stretch the reset signal to guarantee to sample the reset signal.
3.  Synchronous reset require a clock to reset the circuit.


### Asynchronous Reset {#asynchronous-reset}

Asynchronous reset does not depend on the clock and its effect is seen immediately as the reset is applied. Asynchronous reset flip-flop incorporates a reset pin. The reset pin is typically active low, the flip-flop goes into the reset state when the reset signal goes to a logic low (0). The figure below shows the implementation of an asynchronous reset flip-flop with a reset pin.

{{< figure src="/ox-hugo/asyn_rst.svg" caption="<span class=\"figure-number\">Figure 2: </span>Asynchronous Reset Implementation" class="center !important" width="400px" >}}

From the figure it can be seen that additional logic is not required with the input to the flip-flop. To code an asynchoronous reset in Verilog, the reset signal must be included in the sensitivity list. The reset is given the highest priority in this style of coding.


#### Example {#example}

```verilog
module syn_rst(clk, rst, d, q);
  // outputs
   output q;
   // inputs
   input d;
   input clk;
   input rst;

always_ff@(posedge clk or negedge rst)
  if(!rst)
    q <= 1'b0;
  else
    q <= d;

endmodule

```


#### Advantages {#advantages}

1.  Does not require a clock to reset the circuit.
2.  The data path is guaranteed to be clean if asynchronous reset flip-flops are available.


#### Disadvantages {#disadvantages}

1.  Reset assertion is not an issue as the flip-flop takes care of it, but during deassertion when the reset is released close to the active edge of the flip-flop, the flip-flop may go into the metastable stage.
2.  Spurious resets due to noise or glitches on the system reset.


### Reset Deassertion {#reset-deassertion}

Reset deassertion is the process of bring the system out of reset state to operation state. During asynchronous reset deassertion there are two potential problems

<!--list-separator-->

-  Reset Recovery

    -   Reset removal time is the minimum time required between the deassertion of the reset signal and the next active clock edge to ensure proper functionality. This concept is similar to setup time in its importance for guaranteeing stable and reliable operation of digital circuits.

<!--list-separator-->

-  Reset Removal

    -   Reset removal time is the minimum duration for which the reset signal must be deasserted to ensure that flip-flops are correctly initialized.


###  {#d41d8c}

Verilog has three built-in commands to model and test recovery time and signal removal timing checks: $recovery, $removal and $recrem (the latter is a combination of recovery and removal timing checks)[1,2].


### Reset Synchronizer {#reset-synchronizer}

When an asyn reset is deasserted it should satisfy the timing constraints (reset recovery and reset removal) if not chances are that the system may enter into a metastable state. Therefore, it is necessary to pass the data through [Two-Flop Synchronizer] to avoid metastable conditions. Figure 3 illustrates an approach designed to leverage the advantages of both asynchronous and synchronous reset styles.

{{< figure src="/ox-hugo/rst_syn.svg" caption="<span class=\"figure-number\">Figure 3: </span>Async Reset with Synchnronizers" class="center !important" width="700px" >}}

The second flip-flop in the synchronizer ensures that the data Din​ is correctly clocked in by eliminating any metastability caused by asynchronous reset removal and reset deassertion occurring too close to the active edge of the clock.


#### Example Code: {#example-code}

```verilog
module asyn_rst(/*AUTOARG*/
   // Outputs
   rst_main,
   // Inputs
   clk, rst_asyn
   );
  input   clk;
  input   rst_asyn;
  output  rst_main;

  /*AUTOREG*/
  // Beginning of automatic regs (for this module's undeclared outputs)
  reg			rst_main;
  // End of automatics
  /*AUTOWIRE*/

  reg temp_rst;

  always@(posedge clk, negedge rst_asyn)
    begin
        if(!rst_asyn)
                {rst_main, temp_rst} <= 2'b00;
        else
                {rst_main, temp_rst} <= {temp_rst, 1'b1};
    end

endmodule
```

Note: Reset-glitch filtering circuit must be implemented to ensure a clean reset is received in an asynchronous reset circuits.


### Reference {#reference}

1.  [Cummings, Clifford E., and Don Mills. "Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?." SNUG 2002 (Synopsys Users Group Conference, San Jose, CA, 2002) User Papers. 2002.](http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf)
2.  [Cummings, Clifford E., Don Mills, and Steve Golson. "Asynchronous &amp; synchronous reset design techniques-part deux." SNUG Boston 9 (2003).](http://www.sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf)
3.  [Intel® Quartus® Prime Pro Edition User Guide: Design Recommendations](https://www.intel.com/content/www/us/en/docs/programmable/683082/21-3/using-asynchronous-resets.html)
4.  [Alexander Gnusin. "Resets and Reset Domain Crossing in ASIC and FPGA Designs[White Paper]". ALDEC Design Verification Company.](https://research.ssl.berkeley.edu/~teq/research/Resets%20and%20Reset%20Domain%20Crossings%20in%20ASIC%20and%20FPGA%20designs.pdf)
