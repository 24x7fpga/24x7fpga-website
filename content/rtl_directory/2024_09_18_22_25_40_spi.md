+++
title = "SPI"
author = ["Kiran"]
date = 2024-09-18T22:25:00-04:00
tags = ["rtl"]
draft = false
css = "../../zcustom.css"
+++

[Source](https://github.com/24x7fpga/RTL/tree/master/rtl_designs/spi) -- [RTL Design Directory]({{< relref "2024_06_05_00_21_53_rtl_design_directory.md" >}})


## SPI: Overview {#spi-overview}

The Serial Peripheral Interface (SPI) is a widely used communication protocol that enables microcontrollers to interact with external peripherals such as OLED displays, sensors, and SD cards. Known for its simplicity SPI facilitates efficient data exchange between devices in embedded systems.

SPI and [UART]({{< relref "2024_09_17_20_46_04_uart.md" >}}) are both serial communication protocols used to exchange data between peripheral devices, but they differ significantly in how they achieve synchronization. SPI is a synchronous protocol, meaning it relies on a shared clock signal to synchronize data transfer between the transmitter and receiver, ensuring precise timing. In contrast, UART is asynchronous, operating without a clock signal and instead relying on predefined transmission speeds and additional start and stop bits to maintain synchronization. This fundamental difference makes SPI more efficient for high-speed data transfer, while UART is simpler but more prone to timing mismatches and overhead.

{{< figure src="/ox-hugo/spi_block.svg" caption="<span class=\"figure-number\">Figure 1: </span>SPI Controller, Peripheral Connection" >}}

-   **Chip Select (CS)**: This signal is active low and is used to initiate communication with the peripheral device.
-   **Serial Clock (SCK)**: A clock signal generated by the controller to synchronize data transfer between the controller and the peripheral.
-   **Serial Data Out (SDO)**: The data line used by the controller to send serial data to the peripheral device.
-   **Serial Data In (SDI)**: The data line through which the peripheral sends serial data back to the controller.


### SPI Controller {#spi-controller}

An `SPI Controller` is a hardware module that manages communication between a master device (typically a microcontroller or processor) and one or more peripheral devices in an SPI (Serial Peripheral Interface) system. It controls the flow of data by generating the necessary signals for synchronization and data transfer. The SPI controller produces the `Serial Clock (SCK)`, which ensures that both the master and the peripheral are synchronized. It also controls the `Chip Select (CS)` signal, which activates the communication with a specific peripheral device, and manages the `Serial Data Out (SDO)` and `Serial Data In (SDI)` lines to transmit and receive data. The SPI interface can have only one controller, but may control multiple slaves. The controller's role is essential for efficient and reliable data exchange, as it ensures that all timing and signaling requirements are met for smooth communication.


### SPI Peripheral {#spi-peripheral}

An `SPI Peripheral` is a device that communicates with the master controller over the SPI bus. It can be anything from sensors, displays, memory chips, to other microcontrollers. The peripheral is designed to respond to commands from the master by sending or receiving data through the `Serial Data In (SDI)` and `Serial Data Out (SDO)` lines. It is activated when the `Chip Select (CS)` signal from the master is pulled low, indicating the start of communication. The peripheral synchronizes data transfer with the master using the `Serial Clock (SCK)`, which is provided by the SPI controller. The SPI peripheralâ€™s role is to either transmit data to the master or respond to data requests, depending on the operation, while ensuring accurate timing and signal integrity based on the clock and chip select signals.


### Data Transfer {#data-transfer}

-   The SPI protocol operates using a master-slave configuration, where the master (controller) device takes full control of the communication. The master generates the `Serial Clock (SCK)`, ensuring data transfer is perfectly synchronized with the connected peripheral devices.

-   Communication begins when the master pulls the `Chip Select (CS)` line low for the intended peripheral. This activates the specific peripheral, allowing data exchange to take place.

-   In systems with multiple peripherals, each device is typically assigned its own `CS` line, enabling the master to communicate with one device at a time by toggling the appropriate `CS` line.

-   SPI supports full-duplex communication, meaning data is transferred in both directions simultaneously. The master sends data to the peripheral via the `Serial Data Out (SDO)` line, while the peripheral responds with data through the `Serial Data In (SDI)` line. These data transfers occur in parallel, ensuring high-speed communication.

-   The synchronization of data is managed by the `SCK` signal generated by the master. Depending on the chosen communication mode, data is shifted in and out of devices on either the rising or falling edge of the clock signal.

-   Data is transferred in frames, with each frame consisting of a fixed number of bits, commonly 8 bits per byte. For every bit of data, the master sends a clock pulse, ensuring the data is read or written at precisely the right moment.


### Clock Phase and Polarity {#clock-phase-and-polarity}

The SPI interface provides four different clock modes for data transfer, providing a choice of clock phase (delay) and clock polarity (rising or falling edge).

<div class="table-caption">
  <span class="table-number">Table 1:</span>
  Clock Mode
</div>

| Clock Mode | Clock Polarity (CPOL) | Clock Phase (CPHA) | Description                                                                                                                                                           |
|------------|-----------------------|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Mode 0     | 0                     | 0                  | Data is output on the rising edge of the clock (SCK). Input data is latched on the falling edge of the clock.                                                         |
| Mode 1     | 0                     | 1                  | Data is output one-half clock cycle before the first rising edge of SCK and subsequently on the falling edge. Input data is latched on the rising edge of the clock.  |
| Mode 2     | 1                     | 0                  | Data is output on the falling edge of the clock (SCK). Input data is latched on the rising edge of the clock.                                                         |
| Mode 3     | 1                     | 1                  | Data is output one-half clock cycle before the first falling edge of SCK and subsequently on the rising edge. Input data is latched on the falling edge of the clock. |

`Source`: [SPI User Guide](https://www.ti.com/lit/ug/sprugp2a/sprugp2a.pdf)

{{< figure src="/ox-hugo/spi_clk_modes.svg" caption="<span class=\"figure-number\">Figure 2: </span>Clock Modes" >}}


### SPI Transmitter {#spi-transmitter}

The SPI transmitter is a key component of the SPI protocol, also known as SPI Controller, responsible for sending data from the master device to the peripheral. Its operation is synchronized with the `SPI clock (SCK)` to ensure accurate and efficient data transfer.

```verilog
`timescale 1ns/1ns
module spi_tx #(parameter mode = 0, dvsr = 31, width = 8) (/*AUTOARG*/
   // Outputs
   sdo, sclk, cs, tx_dout, tx_rdy, rx_vld,
   // Inputs
   sdi, tx_vld, din, rst, clk
   );
   //outputs
   output sdo;
   output sclk;
   output cs;
   output [width-1: 0] tx_dout;
   output	       tx_rdy;
   output	       rx_vld;

   //input
   input	       sdi;
   input	       tx_vld;
   input [width-1: 0] din;
   input	       rst;
   input	       clk;

   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			rx_vld;
   reg			tx_rdy;
   // End of automatics
   /*AUTOWIRE*/

   // fsm states
   typedef enum {idle, drive, sample} state_type;
   state_type st_reg, st_nxt;

   logic [$clog2(dvsr): 0] dvsr_reg, dvsr_nxt;
   logic [width-1: 0]	   cnt_reg, cnt_nxt;
   logic		   cpol, cpha;
   logic		   temp_clk, sclk_reg, sclk_nxt;
   logic		   cs_reg, cs_nxt;
   logic [width-1:0]	   sdo_reg, sdo_nxt;
   logic [width-1:0]	   sdi_reg, sdi_nxt;

   // spi mode decoder
   always_comb begin
      case(mode)
        'h0 : begin
           cpol = 0;
           cpha = 0;
        end

        'h1 : begin
           cpol = 0;
           cpha = 1;
        end

        'h2 : begin
           cpol = 1;
           cpha = 0;
        end

        'h3 : begin
           cpol = 1;
           cpha = 1;
        end
      endcase // case (mode)
   end // always_comb

   always_ff@(posedge clk)
     if(rst)begin
        st_reg   <= idle;
        cnt_reg  <= 0;
        dvsr_reg <= 0;
        sclk_reg <= 0;
        sdo_reg  <= 0;
        sdi_reg  <= 0;
        cs_reg   <= 1;
     end else begin
        st_reg   <= st_nxt;
        cnt_reg  <= cnt_nxt;
        dvsr_reg <= dvsr_nxt;
        sclk_reg <= sclk_nxt;
        sdo_reg  <= sdo_nxt;
        sdi_reg  <= sdi_nxt;
        cs_reg   <= cs_nxt;
     end

   always_comb begin
      st_nxt   = st_reg;
      cnt_nxt  = cnt_reg;
      dvsr_nxt = dvsr_reg;
      sdo_nxt  = sdo_reg;
      cs_nxt   = cs_reg;

      rx_vld   = 0;

      case(st_reg)

        idle: begin
           if(tx_vld)begin
              cs_nxt = 0;
              dvsr_nxt = dvsr_reg + 1;
              if(dvsr_reg == dvsr)begin
                      st_nxt = drive;
                      dvsr_nxt = 0;
              end
           end
        end

        drive: begin
           sdo_nxt = din << cnt_reg;
           dvsr_nxt = dvsr_reg + 1;
           if(dvsr_reg == dvsr)begin
              st_nxt = sample;
              dvsr_nxt = 0;
           end
        end

        sample: begin
           // read sdi
           sdi_nxt[width-1-cnt_reg] = sdi;

           dvsr_nxt = dvsr_reg + 1;
           if(dvsr_reg == dvsr)begin
              cnt_nxt = cnt_reg + 1;
              dvsr_nxt = 0;

              if(cnt_reg == width-1) begin
                      cnt_nxt = 0;
                      rx_vld  = 1;
                      if(~tx_vld)
                          st_nxt  = idle;
                  end
                      st_nxt = drive;
                  end
        end

      endcase // case (st_reg)
   end // always_comb

   // look-ahead decoder
   assign temp_clk = (st_nxt == drive && cpha) || (st_nxt == sample && ~cpha);

   // spi clk
   assign sclk_nxt = (cpol) ? ~temp_clk : temp_clk;

   // registered data
   assign cs   = cs_reg;
   assign sclk = sclk_reg;
   assign sdo  = sdo_reg[width-1];
   assign tx_dout = sdi_reg;

endmodule // spi_tx
// Local Variables:
// Verilog-Library-Directories: (".")
// End:
```


### SPI Receiver {#spi-receiver}

The SPI receiver is the peripheral device in an SPI communication system responsible for receiving data from the master device. It works in synchronization with the master by relying on the clock signal (SCK) generated by the master for precise timing.

```verilog
`timescale 1ns/1ns
module spi_rx #(parameter mode = 0, width = 8) (/*AUTOARG*/
   // Outputs
   sdi, rx_dout,
   // Inputs
   sdo, sclk, cs, rst, clk
   );
   // outputs
   output sdi;
   output [width-1:0] rx_dout;

   //input
   input	      sdo;
   input	      sclk;
   input	      cs;
   input	      rst;
   input	      clk;


   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			sdi;
   // End of automatics
   /*AUTOWIRE*/

   // fsm states
   typedef enum {idle, sample} state_type;

   state_type st_reg, st_nxt;

   logic [width-1:0]	  cnt_reg, cnt_nxt;
   logic [width-1:0]	  din_reg, din_nxt;

  generate
     if(mode == 0 || mode == 3)begin
        always_ff@(posedge sclk, posedge rst)
          if(rst)begin
             st_reg <= idle;
             cnt_reg <= 0;
             din_reg <= 0;
          end else begin
             st_reg <= st_nxt;
             cnt_reg  <= cnt_nxt;
             if(~cs)begin
                din_reg <= {din_reg[width-2:0],sdo};
                sdi <= din_reg[width-1];
             end
          end
     end

     if(mode == 1 || mode == 2)begin
        always_ff@(negedge sclk, posedge rst)
          if(rst)begin
             st_reg  <= idle;
             cnt_reg <= 0;
             din_reg <= 0;
          end else begin
             st_reg  <= st_nxt;
             cnt_reg <= cnt_nxt;
             if(~cs)begin
                din_reg <= {din_reg[width-2:0],sdo};
                sdi     <= din_reg[width-1];
             end
          end
     end
   endgenerate


   always_comb begin
      st_nxt = st_reg;
      din_nxt=din_reg;
      cnt_nxt=cnt_reg;

      case (st_reg)

      idle: begin
            if(~cs)
                st_nxt = sample;
            end

      sample: begin
            if(cnt_reg == width-1)
                cnt_nxt = 0;
            else
                cnt_nxt = cnt_reg + 1;
            end

    endcase

end

   assign rx_dout = (cnt_reg == width-1) ? din_reg : 'h0;

endmodule
// Local Variables:
// Verilog-Library-Directories: (".")
// End:
```


### SPI Wrapper {#spi-wrapper}

The SPI wrapper encapsulates the functionality of the SPI controller and peripheral, providing a standardized interface for users and applications.

```verilog
`timescale 1ns/1ns
module spi #(parameter mode = 0, dvsr = 31, width = 8)(/*AUTOARG*/
   // Outputs
   rx_vld, rx_dout, tx_dout,
   // Inputs
   clk, rst, din, tx_vld
   );
   input  clk;
   input  rst;
   input [width-1:0] din;
   input	     tx_vld;
   output	     rx_vld;
   output [width-1:0] rx_dout;
   output [width-1:0] tx_dout;




  /*AUTOREG*/
  /*AUTOWIRE*/
  // Beginning of automatic wires (for undeclared instantiated-module outputs)
  wire			cs;			// From MOD1 of spi_tx.v
  wire			sdi;			// From MOD1 of spi_rx.v
  wire			sdo;			// From MOD1 of spi_tx.v
  wire			sclk;			// From MOD1 of spi_tx.v
  wire			tx_rdy;			// From MOD1 of spi_tx.v
  // End of automatics

spi_tx #(/*AUTOINSTPARAM*/
         // Parameters
         .mode				(mode),
         .dvsr				(dvsr),
         .width				(width)) SPI_MASTER (/*AUTOINST*/
                                                       // Outputs
                                                       .sdo		(sdo),
                                                       .sclk		(sclk),
                                                       .cs		(cs),
                                                       .tx_dout		(tx_dout[width-1:0]),
                                                       .tx_rdy		(tx_rdy),
                                                       .rx_vld		(rx_vld),
                                                       .din		(din[width-1:0]),
                                                       // Inputs
                                                       .sdi		(sdi),
                                                       .tx_vld		(tx_vld),
                                                       .rst		(rst),
                                                       .clk		(clk));
spi_rx #(/*AUTOINSTPARAM*/
         // Parameters
         .mode				(mode),
         .width				(width)) SPI_SLAVE (/*AUTOINST*/
                                                       // Outputs
                                                       .sdi		(sdi),
                                                       .rx_dout		(rx_dout[width-1:0]),
                                                       // Inputs
                                                       .sdo		(sdo),
                                                       .sclk		(sclk),
                                                       .cs		(cs),
                                                       .rst		(rst),
                                                       .clk		(clk));

endmodule
// Local Variables:
// Verilog-Library-Directories: (".")
// End:
```


### Testbench {#testbench}

```verilog
`timescale 1ns/1ns
module tb_spi();
   localparam t = 8;
   logic      clk;
   logic      rst;

   localparam mode  = 3;
   localparam dvsr  = 31;
   localparam width = 8;

   logic [width-1:0] din;
   logic             tx_vld;


   /*AUTOREG*/
   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire [width-1:0]	rx_dout;		// From DUT of spi.v
   wire			rx_vld;			// From DUT of spi.v
   wire [width-1:0]	tx_dout;		// From DUT of spi.v
   // End of automatics
   spi #(/*AUTOINSTPARAM*/
         // Parameters
         .mode				(mode),
         .dvsr				(dvsr),
         .width				(width)) DUT (/*AUTOINST*/
                                                      // Outputs
                                                      .rx_vld		(rx_vld),
                                                      .rx_dout		(rx_dout[width-1:0]),
                                                      .tx_dout		(tx_dout[width-1:0]),
                                                      // Inputs
                                                      .clk		(clk),
                                                      .rst		(rst),
                                                      .din		(din[width-1:0]),
                                                      .tx_vld		(tx_vld));

   always #(t/2) clk = (clk === 1'b0);
   initial begin
      rst = 1;
      din ='h95;
      tx_vld = 0;
      #(2*t);
      rst = 0;
      #(3*t);
      tx_vld = 1;
      wait(rx_vld);
      #(3*t);
      wait(rx_vld);
      $display("tx_dout = %0h and rx_dout = %0h", tx_dout, rx_dout);

      if(tx_dout == rx_dout)begin
           $display("Simulation PASS ;)");
           $finish;
         end else begin
       $display("Simulation FAIL ;)");
           $finish;
         end
   end // initial begin

   initial begin
      $dumpfile("tb_spi.vcd");
      $dumpvars(0,tb_spi);
   end
endmodule
// Local Variables:
// Verilog-Library-Directories: (".")
// End:
```
