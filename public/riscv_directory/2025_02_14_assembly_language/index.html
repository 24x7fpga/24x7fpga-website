<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Assembly Language | Home</title>
<meta name="keywords" content="riscv">
<meta name="description" content="
Machine language, which consists solely of 1&rsquo;s and 0&rsquo;s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/riscv_directory/2025_02_14_assembly_language/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.28ee19e1ed9d982499c62390d2acb416195f5655651bae2a84b5090fab8908e0.css" integrity="sha256-KO4Z4e2dmCSZxiOQ0qy0FhlfVlVlG64qhLUJD6uJCOA=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://24x7fpga.com/riscv_directory/2025_02_14_assembly_language/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">


<meta property="og:title" content="Assembly Language" />
<meta property="og:description" content="
Machine language, which consists solely of 1&rsquo;s and 0&rsquo;s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/riscv_directory/2025_02_14_assembly_language/" /><meta property="article:section" content="riscv_directory" />
<meta property="article:published_time" content="2025-02-14T15:07:00-05:00" />
<meta property="article:modified_time" content="2025-02-14T15:07:00-05:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Assembly Language"/>
<meta name="twitter:description" content="
Machine language, which consists solely of 1&rsquo;s and 0&rsquo;s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Riscv_directories",
      "item": "https://24x7fpga.com/riscv_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Assembly Language",
      "item": "https://24x7fpga.com/riscv_directory/2025_02_14_assembly_language/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Assembly Language",
  "name": "Assembly Language",
  "description": " Machine language, which consists solely of 1\u0026rsquo;s and 0\u0026rsquo;s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored.\n",
  "keywords": [
    "riscv"
  ],
  "articleBody": " Machine language, which consists solely of 1’s and 0’s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored.\nLoad Instruction The first instruction to learn in RISC-V assembly is how to load an immediate value into a register using the li (Load Immediate) command. This command directly places an immediate (constant) value into a register.\nRISC-V has 32 registers, and for this example, we will use a temporary register to store an integer value.\nli x5,8 The above instruction loads the value 8 into the temporary register x5. To understand how this command works, let’s look at the figure below, which shows a RISC-V simulation using ripes.me.\nFigure 1: Load Immediate\nThe li command is a pseudo-instruction in RISC-V, meaning it is not a native hardware instruction but gets translated into actual RISC-V instructions during assembly. Under the hood, li is converted into an addi instruction:\naddi x5, x0, 8 Here’s what happens:\nThe zero register (x0) always holds the value 0. The immediate value (8) is added to x0 and stored in x5. This effectively loads 8 into x5. Another common instruction is lw (Load Word), which loads a value from memory into a register. While li loads an immediate value, lw retrieves data stored in memory.\nFigure 2: Load From Memory\nThe .data section is used to store global or static data. The .text section marks the beginning of the program logic that will be executed.\nAdd and Sub Instruction Now that we know even a simple load command, which seems trivial, is internally executed using an add instruction, let’s dive deeper into addition and subtraction commands in RISC-V. Let’s explore how the add and sub instructions work and how they manipulate register values in a RISC-V program.\n.data w: .word 5 .text lw x5, w li x6, 8 add x5, x5, x6 sub x6, x5, x6 The above program demonstrates loading values into registers and performing basic arithmetic operations using add and sub instructions.\nLoading Constants\nThe program first loads the constant 5 into register x5. After execution: x5 = 5. Then, the li instruction loads the number 8 into register x6. After execution: x6 = 8. Addition Operation\nThe add instruction adds the values in x5 and x6 and stores the result in x5. Calculation: x5 = x5 + x6 = 5 + 8 = 13. Now, x5 = 13, while x6 remains 8. Subtraction Operation\nThe sub instruction subtracts x6 from x5 and stores the result in x6. Calculation: x6 = x5 - x6 = 13 - 8 = 5. Now, x6 = 5, while x5 remains 13. Figure 3: ADD and SUB Instruction\nFigure 4, shows the result of data stored in the registers. The register x5 = 13 (0x0d) and the register x6 = 5 (0x05).\nFigure 4: Register Values\nLogical Operation Logical operations in RISC-V include and, or, and xor, which perform bitwise operations on two source registers and store the result in a destination register. In addition to these standard logical operations, RISC-V provides immediate versions of these instructions: and, ori, xori each bitwise logical operation with an immediate value. These immediate versions allow direct manipulation of register values without needing a second source register. Below is a RISC-V program demonstrating the use of logical operations and their immediate versions in action.\nFigure 5: Logical Operations\nThe register values for the logical operations of the above program is shown in Figure 6.\nFigure 6: Register Values\nThe logical operations are simple but the most trivial operations in programming. The and operation is useful for clearing or masking bits, it forces the unwanted bits to zero. The or operation is useful for combining two bits registers, forces a bit to one. The xori operation is used to perform a NOT operation with xori x5, x6, -1. The -1 is 0XFFF is sign-extended to 0xFFFF_FFFF. XOR with all ones will invert the input.\nLogical operations are fundamental yet powerful in programming. They allow efficient bitwise manipulation, which is crucial for low-level programming and hardware interactions.\nMasking or Clearing Bits The and operation is primarily used for clearing or masking specific bits. It forces unwanted bits to zero while preserving others.\nCombining Bits The or operation is useful for combining bit values from two registers. It ensures that certain bits are set to one, while leaving others unchanged.\nInverting Bits The xori instruction is commonly used for bitwise negation, NOT operation). The XOR truth table is shown below:\nA B Z 0 0 0 0 1 1 1 0 1 1 1 0 The invert operation in assembly is shown below:\nxori x5, x6, -1 The number -1 which is 0xF gets sign-extended to 0xFFFF_FFFF, meaning all 32-bits are ones. Performing an XOR operation with all ones effectively inverts the bits of x6, storing the result in x5.\nShift Operation As the name suggests, the input is shifted to left or right dropping the bits at the end. The left shift adds zeros to the least significant bit. And the right shift can be arithmetic or logical. Just like logical operations the shift operation also have it shift immediate counterparts.\nAs the name suggests, shift operations move the bits of a register left or right, dropping or preserving the bit. These operations are useful for multiplication, division, and bit manipulation.\nLeft shift (sll): The input shifts the bits to the left, filling the least significant bits with zeros. This operations is smilar to multipling the number by 2ⁿ, where n is the shift amount. Logical Right Shift (srl): The right shift the data to the right by the desired amount and fills the most significant bits with zeros. This is and unsigned shift. Arithemetic Right Shift (sra): Preserves the sign bit (most significant bit), ensuring correct division for signed numbers. Right shift also suffices as a 2ⁿ division. Like logical operations, shift instructions also have immediate counterparts slli, srli and srai, where the shift amount is provided as an immediate value instead of a register.\nFigure 7: Shift Operation\nThe register values are shown in Figure 8.\nFigure 8: Register Values\nMultiply Instruction Multiplication is one of the fundamental computational operations. When multiplying two N-bit numbers, the result is a 2N-bit product. Since RISC-V is a 32-bit architecture, special handling is needed for 64-bit results.\n32-bit Multiply (mul): Multiplies two 32-bit numbers and retains only the least significant 32 bits. The upper 32 bits are discarded. Best used when the product is known to fit within 32 bits. 64-bit Multiply High: For full 64-bit multiplication, RISC-V provides three variants to store the most significant bits separately: mulh: Treats both operands as signed. mulhsu: Treats the first operand as signed, second as unsigned. mulhu: Both operands are unsigned. By combining mulh and mul, a full 64-bit product can be stored across two registers, enabling high-precision arithmetic.\nFigure 9 shows the multiplication operation in RISC-V assembly. Two 32-bit values are loaded into registers x5 and x6. The mul instruction multiplies these values and stores the lower 32 bits of the result in register x7. To handle the full 64-bit product, the mulh instruction is used in combination with mul to store the upper 32 bits of the result in x8 and the lower 32 bits in x9. This way, the 64-bit result is is obtained and split across two registers, x8 and x9.\nFigure 9: Multiplication Operation\nThe register values are shown in Figure 10.\nFigure 10: Register Values\nConditional Branches Branch instructions are used to either execute or skip certain instructions based on the comparison of two values. In RISC-V, there are a total of six branch instructions, which allow for conditional jumps in the program flow. These instructions are as follows:\nbeq: Branch If Equal bne: Branch If Not Equal blt: Branch If Less Than bge: Branch If Greater Than bltu: Branch If Less Than (unsigned) bgeu: Branch If Greater Than (unsigned) A label is used in conditional branch instructions to specify the target location where the program should jump, depending on whether the condition is satisfied or not. Figure 11, illustrates the use of conditional branching in a program. If a branch condition is satisfied, the program jumps to the target label or else the program flow continues.\nFigure 11: Multiplication Operation\nThe register values are shown in Figure 12. The register x9 remains zero because the branch condition is satified and the program skips to the specified label.\nFigure 12: Register Values\nJumps The jump instruction allows the program to skip a set of instructions and continue execution from a target label. RISC-V provides three types of jump instructions:\nJump j – A simple jump that ensures certain lines of code are skipped. Jump and Link jal – Used to call a function while saving the return address. Jump Register jr – Used to return from a function by jumping to the address stored in a register. The program below shows the execution of a simple jump instruction.\nFigure 13: Jump Instruction\nBy examining the register values, it is evident that registers x7 and x8 remain zero, indicating that the add and sub instructions were skipped.\nFigure 14: Register Values\nIf and If/Else Statments Now that we have learned about conditional branch and jump instructions, let’s implement if and if-else statements—one of the most widely used branching constructs in high-level programming languages.\nIf Statement The if statement can be implemented using conditional branch instructions, as demonstrated in the program below:\nFigure 15: If Statement\nIn the program, if the values in registers x5 and x6 are not equal, the execution jumps to the branch label NEQUAL. This means the instructions immediately following the condition are skipped, and the program continues execution from the labeled section.\nFigure 16: Register Values\nIf/Else Statement Similar to the if statement, the if-else statement uses conditional branch along with jump instruction to perform the else operation. The program below illustrates the implementation of if-else statement.\nFigure 17: If Statement\nIn this case, if the values in registers x5 and x6 are equal, the program takes the branch. Otherwise, it continues executing the immediate instructions. The jump instruction j ensures that the branch executes correctly by jumping to the else label, handling the else statement effectively.\nFigure 18: Register Values\nCase Statement A case statement is another form of the if-else condition commonly used in high-level languages to select an output from multiple input conditions. In RISC-V, case statements are implemented using a combination of conditional branch and jump instructions to efficiently execute the corresponding code block based on the given condition.\nFigure 19: Case Statement\nThe program demonstrates a simple 2:1 multiplexer (MUX) implementation using conditional branching. Here, the select line is stored in register x5. The case statement checks for values ranging from 0 to 3, and if the select line matches any of these values, the output is set to select line + 1.\nFigure 20: Register Values\nWhile Loops Loops are a crucial programming construct that allows a piece of code to be executed repeatedly. One of the most commonly used looping structure is the while loop. In assembly, loops are implemented using conditional branching in combination with jump instructions. In the following program, we will explore how to implement a while loop in RISC-V using branch and jump instructions.\nFigure 21: Case Statement\nThe program demonstrates a simple counter using branch, jump and arithmetic instructions. The counter is stored in register x6, and it increments until it reaches the value stored in register x5. The beq (branch if equal) instruction checks whether the value in x6 is equal to x5. If the values are not equal, the counter x6 is incremented by 1, and the loop continues. Once x6 reaches x5, the program branches to the label done, exiting the loop.\nFigure 22: Register Values\nFor Loop Another important looping construct is the for loop, which provides a structured way to repeat a block of code with an initialization, condition check, and iteration step. Let’s implement another counter program using a for loop, with a slight variation from the previous example. This version explicitly sets up the loop with an initial value, a condition check, and an increment operation, closely resembling the for loop structure in high-level languages.\nFigure 23: Case Statement\nThe program computes the sum of a sequence by repeatedly adding the value of i to sum. The sum is stored in register x7, while the loop variable i is stored in register x6. A branching condition checks whether i has reached the total number of iterations stored in register x5. If i is not equal to x5, the loop continues, adding i to sum and incrementing i. Once i reaches x5, the loop exits, and the final sum is stored in x7.\nFigure 24: Register Values\nFunction Calls Function calls are an essential design methodology that allows code reuse. In RISC-V, function calls are implemented using the jump and link jal instruction and jump register jr instruction, with the return address ra register storing the return location. The following program demonstrates function calls for simple addition and multiplication operations in RISC-V assembly. These functions take two input values, perform the respective operations, and return the result.\nFigure 25: Function Call\nIn Figure 25, the right side displays the memory address corresponding to each instruction. This helps visualize how instructions are stored and executed sequentially. Figure 26 illustrates the register values after executing the function. Notably, the return address ra register holds the value 14, which corresponds to the next instruction after the function call. This ensures that after executing the function, the program resumes execution from the correct point. This way the jump and link jal, jump register jr, and return address ra register to manage program flow efficiently.\nFigure 26: Register Values\nStack The stack is a crucial memory element in a processor, primarily used for storing register contents when a program exhausts resources or during a function call, where register values need to be saved before modification. The stack pointer sp points to the address of the stack. Unlike regular memory storage, where addresses increase as data is stored, the stack follows a last-in, first-out (LIFO) principle. The stack pointer starts at the highest memory address and decrements as data is pushed onto the stack. This mechanism ensures that temporary data, such as function arguments and return addresses, are efficiently stored and retrieved, making function calls and resource management efficient.\nFigure 27: Stack for Storing Register Values\nThe example program used in fucntion call is modified to save the register contents onto the stack before performing the arithmetic operation. Figure 27 illustrates the use of the save sw and load lw instructions to store and retrieve register values from the stack. Before storing any data, it is essential to allocate the required memory space on the stack. This is done by decrementing the stack pointer sp by 8, ensuring enough space to store two 32-bit values.\nFigure 28: Register Values\nFigure 29, shows the contents of the stack memory. The register value x6 and x7 are stored in the addresses 0x7FFF_FFEC and 0x7FFF_FFE8 respectively.\nFigure 29: Stack Memory\nRecursive Function One of the classic examples of a recursive function is computing the factorial of a number. Recursion is a powerful concept where a function calls itself to break down a problem into smaller subproblems. Below, we first implement the factorial function in C, followed by its equivalent RISC-V assembly implementation, demonstrating how recursion is handled at the low level.\nint fact (int n){ if(n\u003c=1){ return 1 } else { return (n * fact(n-1)) } Let’s take an example where n = 4, and the function fact(4) is called. The if condition checks whether n is less than or equal to 1. If true, it returns 1. Otherwise, the else condition is executed, which returns the multiplication of n * fact(n-1).\nFor n = 4, the function returns:\n4 * fact(3) This process continues recursively until n-1 reaches the base case (n = 1). At this point, the recursive calls begin to resolve, forming the expression:\n(4 * (3 * (2 * (1)))) Figure 30 illustrates the assembly implementation of a recursive function. To ensure the recursion works effectively, it is necessary to store the return address ra and any registers that will be modified on the stack before making repeated function calls. In this example, the register x5 is saved on the stack along with ra before each recursive call. This preserves the previous values, allowing the function to return correctly once the recursion starts unfolding.\nFigure 30: Factorial Program\nFigure 31, shows the register values of the program, the register x5 hold the result of the factorial.\nFigure 31: Register Values\nFigure 32 illustrates the stack memory layout during a recursive function call. The memory address 0x7FFF_FFEC holds the return address ra register, while 0x7FFF_FFE8 stores the value of register x5. Each time a function call occurs, the current return address and register values are pushed onto the stack, ensuring they can be restored once the function completes and returns.\nFigure 32: Stack Memory\n",
  "wordCount" : "2908",
  "inLanguage": "en",
  "datePublished": "2025-02-14T15:07:00-05:00",
  "dateModified": "2025-02-14T15:07:00-05:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/riscv_directory/2025_02_14_assembly_language/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 15"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>







<script src="https://24x7fpga.com/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Assembly Language
    </h1>
    <div class="post-meta"><span title='2025-02-14 15:07:00 -0500 EST'>February 14, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2908 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><h2 id="d41d8c"><a hidden class="anchor" aria-hidden="true" href="#d41d8c">#</a></h2>
<p>Machine language, which consists solely of 1&rsquo;s and 0&rsquo;s, is the language understood by machines. Writing even a simple addition operation in machine language requires extensive effort; therefore, assembly language is used to make programs more readable and understandable for humans. Assembly language is then converted into machine language using a compiler. In this section, basic assembly language operations and the micro-operations required for their execution will be explored.</p>
<h3 id="load-instruction">Load Instruction<a hidden class="anchor" aria-hidden="true" href="#load-instruction">#</a></h3>
<p>The first instruction to learn in RISC-V assembly is how to load an immediate value into a register using the <code>li</code> (Load Immediate) command. This command directly places an immediate (constant) value into a register.</p>
<p>RISC-V has 32 registers, and for this example, we will use a temporary register to store an integer value.</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">li x5,8
</code></pre><p>The above instruction loads the value 8 into the temporary register <code>x5</code>. To understand how this command works, let&rsquo;s look at the figure below, which shows a RISC-V simulation using <a href="https://ripes.me/">ripes.me</a>.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/li.png"
         alt="Figure 1: Load Immediate"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>Load Immediate</p>
        </figcaption>
</figure>

<p>The <code>li</code> command is a pseudo-instruction in RISC-V, meaning it is not a native hardware instruction but gets translated into actual RISC-V instructions during assembly. Under the hood, <code>li</code> is converted into an <code>addi</code> instruction:</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">addi x5, x0, 8
</code></pre><p>Here’s what happens:</p>
<ul>
<li>The zero register (x0) always holds the value 0.</li>
<li>The immediate value (8) is added to x0 and stored in x5.</li>
<li>This effectively loads 8 into x5.</li>
</ul>
<p>Another common instruction is lw (Load Word), which loads a value from memory into a register. While li loads an immediate value, lw retrieves data stored in memory.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/lw.png"
         alt="Figure 2: Load From Memory"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>Load From Memory</p>
        </figcaption>
</figure>

<p>The <code>.data</code> section is used to store global or static data. The <code>.text</code> section marks the beginning of the program logic that will be executed.</p>
<h3 id="add-and-sub-instruction">Add and Sub Instruction<a hidden class="anchor" aria-hidden="true" href="#add-and-sub-instruction">#</a></h3>
<p>Now that we know even a simple load command, which seems trivial, is internally executed using an <code>add</code> instruction, let&rsquo;s dive deeper into addition and subtraction commands in RISC-V. Let&rsquo;s explore how the add and sub instructions work and how they manipulate register values in a RISC-V program.</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">.data
w: .word 5
.text
lw x5, w
li x6, 8
add x5, x5, x6
sub x6, x5, x6
</code></pre><p>The above program demonstrates loading values into registers and performing basic arithmetic operations using <code>add</code> and <code>sub</code> instructions.</p>
<ul>
<li>
<p>Loading Constants</p>
<ul>
<li>The program first loads the constant 5 into register x5. After execution: x5 = 5. Then, the <code>li</code> instruction loads the number 8 into register x6. After execution: x6 = 8.</li>
</ul>
</li>
<li>
<p>Addition Operation</p>
<ul>
<li>The <code>add</code> instruction adds the values in x5 and x6 and stores the result in x5. Calculation: x5 = x5 + x6 = 5 + 8 = 13. Now, x5 = 13, while x6 remains 8.</li>
</ul>
</li>
<li>
<p>Subtraction Operation</p>
<ul>
<li>The <code>sub</code> instruction subtracts x6 from x5 and stores the result in x6. Calculation: x6 = x5 - x6 = 13 - 8 = 5. Now, x6 = 5, while x5 remains 13.</li>
</ul>
</li>
</ul>
<figure>
    <img loading="lazy" src="/ox-hugo/add_sub.png"
         alt="Figure 3: ADD and SUB Instruction"/> <figcaption>
            <p><span class="figure-number">Figure 3: </span>ADD and SUB Instruction</p>
        </figcaption>
</figure>

<p>Figure 4, shows the result of data stored in the registers. The register x5 = 13 (0x0d) and the register x6 = 5 (0x05).</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/add_sub_reg.png"
         alt="Figure 4: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 4: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="logical-operation">Logical Operation<a hidden class="anchor" aria-hidden="true" href="#logical-operation">#</a></h3>
<p>Logical operations in RISC-V include <code>and</code>, <code>or</code>, and <code>xor</code>, which perform bitwise operations on two source registers and store the result in a destination register. In addition to these standard logical operations, RISC-V provides immediate versions of these instructions: <code>and</code>, <code>ori</code>, <code>xori</code> each bitwise logical operation with an immediate value. These immediate versions allow direct manipulation of register values without needing a second source register. Below is a RISC-V program demonstrating the use of logical operations and their immediate versions in action.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/logical.png"
         alt="Figure 5: Logical Operations"/> <figcaption>
            <p><span class="figure-number">Figure 5: </span>Logical Operations</p>
        </figcaption>
</figure>

<p>The register values for the logical operations of the above program is shown in Figure 6.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/logical_reg.png"
         alt="Figure 6: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 6: </span>Register Values</p>
        </figcaption>
</figure>

<p>The logical operations are simple but the most trivial operations in programming. The <code>and</code> operation is useful for <em>clearing</em> or <em>masking</em> bits, it forces the unwanted bits to zero. The <code>or</code> operation is useful for combining two bits registers, forces a bit to one. The <code>xori</code> operation is used to perform a <em>NOT</em> operation with <code>xori x5, x6, -1</code>. The -1 is 0XFFF is sign-extended to 0xFFFF_FFFF. XOR with all ones will invert the input.</p>
<p>Logical operations are fundamental yet powerful in programming. They allow efficient bitwise manipulation, which is crucial for low-level programming and hardware interactions.</p>
<h4 id="masking-or-clearing-bits">Masking or Clearing Bits<a hidden class="anchor" aria-hidden="true" href="#masking-or-clearing-bits">#</a></h4>
<p>The <code>and</code> operation is primarily used for <em>clearing</em> or <em>masking</em> specific bits. It forces unwanted bits to zero while preserving others.</p>
<h4 id="combining-bits">Combining Bits<a hidden class="anchor" aria-hidden="true" href="#combining-bits">#</a></h4>
<p>The <code>or</code> operation is useful for <em>combining</em> bit values from two registers. It ensures that certain bits are set to one, while leaving others unchanged.</p>
<h4 id="inverting-bits">Inverting Bits<a hidden class="anchor" aria-hidden="true" href="#inverting-bits">#</a></h4>
<p>The xori instruction is commonly used for bitwise negation, <em>NOT</em> operation). The <em>XOR</em> truth table is shown below:</p>
<table>
  <thead>
      <tr>
          <th>A</th>
          <th>B</th>
          <th>Z</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>0</td>
          <td>0</td>
      </tr>
      <tr>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>0</strong></td>
          <td><strong>1</strong></td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>1</strong></td>
          <td><strong>0</strong></td>
      </tr>
  </tbody>
</table>
<p>The invert operation in assembly is shown below:</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">xori x5, x6, -1
</code></pre><p>The number -1 which is 0xF gets sign-extended to 0xFFFF_FFFF, meaning all 32-bits are ones. Performing an <em>XOR</em> operation with all ones effectively inverts the bits of <code>x6</code>, storing the result in <code>x5</code>.</p>
<h3 id="shift-operation">Shift Operation<a hidden class="anchor" aria-hidden="true" href="#shift-operation">#</a></h3>
<p>As the name suggests, the input is shifted to left or right dropping the bits at the end. The left shift adds zeros to the least significant bit. And the right shift can be arithmetic or logical. Just like logical operations the shift operation also have it shift immediate counterparts.</p>
<p>As the name suggests, shift operations move the bits of a register left or right, dropping or preserving the bit. These operations are useful for multiplication, division, and bit manipulation.</p>
<ul>
<li>Left shift (<code>sll</code>): The input shifts the bits to the left, filling the least significant bits with zeros. This operations is smilar to multipling the number by 2ⁿ, where n is the shift amount.</li>
<li>Logical Right Shift (<code>srl</code>): The right shift  the data to the right by the desired amount and fills the most significant bits with zeros. This is and unsigned shift.</li>
<li>Arithemetic Right Shift (<code>sra</code>): Preserves the sign bit (most significant bit), ensuring correct division for signed numbers.</li>
</ul>
<p>Right shift also suffices as a 2ⁿ division. Like logical operations, shift instructions also have immediate counterparts <code>slli</code>, <code>srli</code> and <code>srai</code>, where the shift amount is provided as an immediate value instead of a register.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/shift.png"
         alt="Figure 7: Shift Operation"/> <figcaption>
            <p><span class="figure-number">Figure 7: </span>Shift Operation</p>
        </figcaption>
</figure>

<p>The register values are shown in Figure 8.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/shift_reg.png"
         alt="Figure 8: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 8: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="multiply-instruction">Multiply Instruction<a hidden class="anchor" aria-hidden="true" href="#multiply-instruction">#</a></h3>
<p>Multiplication is one of the fundamental computational operations. When multiplying two N-bit numbers, the result is a 2N-bit product. Since RISC-V is a 32-bit architecture, special handling is needed for 64-bit results.</p>
<ul>
<li>32-bit Multiply (<code>mul</code>): Multiplies two 32-bit numbers and retains only the least significant 32 bits. The upper 32 bits are discarded. Best used when the product is known to fit within 32 bits.</li>
<li>64-bit Multiply High: For full 64-bit multiplication, RISC-V provides three variants to store the most significant bits separately:
<ul>
<li><code>mulh</code>: Treats both operands as signed.</li>
<li><code>mulhsu</code>: Treats the first operand as signed, second as unsigned.</li>
<li><code>mulhu</code>: Both operands are unsigned.</li>
</ul>
</li>
</ul>
<p>By combining <code>mulh</code> and <code>mul</code>, a full 64-bit product can be stored across two registers, enabling high-precision arithmetic.</p>
<p>Figure 9 shows the multiplication operation in RISC-V assembly. Two 32-bit values are loaded into registers <code>x5</code> and <code>x6</code>. The <code>mul</code> instruction multiplies these values and stores the lower 32 bits of the result in register <code>x7</code>. To handle the full 64-bit product, the <code>mulh</code> instruction is used in combination with <code>mul</code> to store the upper 32 bits of the result in <code>x8</code> and the lower 32 bits in <code>x9</code>. This way, the 64-bit result is is obtained and split across two registers, <code>x8</code> and <code>x9</code>.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/mul.png"
         alt="Figure 9: Multiplication Operation"/> <figcaption>
            <p><span class="figure-number">Figure 9: </span>Multiplication Operation</p>
        </figcaption>
</figure>

<p>The register values are shown in Figure 10.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/mul_reg.png"
         alt="Figure 10: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 10: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="conditional-branches">Conditional Branches<a hidden class="anchor" aria-hidden="true" href="#conditional-branches">#</a></h3>
<p>Branch instructions are used to either execute or skip certain instructions based on the comparison of two values. In RISC-V, there are a total of six branch instructions, which allow for conditional jumps in the program flow. These instructions are as follows:</p>
<ol>
<li><code>beq</code>: Branch If Equal</li>
<li><code>bne</code>: Branch If Not Equal</li>
<li><code>blt</code>: Branch If Less Than</li>
<li><code>bge</code>: Branch If Greater Than</li>
<li><code>bltu</code>: Branch If Less Than (unsigned)</li>
<li><code>bgeu</code>:  Branch If Greater Than (unsigned)</li>
</ol>
<p>A <strong>label</strong> is used in conditional branch instructions to specify the target location where the program should jump, depending on whether the condition is satisfied or not. Figure 11, illustrates the use of conditional branching in a program. If a branch condition is satisfied, the program jumps to the target label or else the program flow continues.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/cond_branch.png"
         alt="Figure 11: Multiplication Operation"/> <figcaption>
            <p><span class="figure-number">Figure 11: </span>Multiplication Operation</p>
        </figcaption>
</figure>

<p>The register values are shown in Figure 12. The register <code>x9</code> remains zero because the branch condition is satified and the program skips to the specified <strong>label</strong>.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/cond_branch_reg.png"
         alt="Figure 12: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 12: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="jumps">Jumps<a hidden class="anchor" aria-hidden="true" href="#jumps">#</a></h3>
<p>The jump instruction allows the program to skip a set of instructions and continue execution from a target label. RISC-V provides three types of jump instructions:</p>
<ul>
<li>Jump <code>j</code> – A simple jump that ensures certain lines of code are skipped.</li>
<li>Jump and Link <code>jal</code> – Used to call a function while saving the return address.</li>
<li>Jump Register <code>jr</code> – Used to return from a function by jumping to the address stored in a register.</li>
</ul>
<p>The program below shows the execution of a simple jump instruction.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/jump.png"
         alt="Figure 13: Jump Instruction"/> <figcaption>
            <p><span class="figure-number">Figure 13: </span>Jump Instruction</p>
        </figcaption>
</figure>

<p>By examining the register values, it is evident that registers <code>x7</code> and <code>x8</code> remain zero, indicating that the <code>add</code> and <code>sub</code> instructions were skipped.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/jump_reg.png"
         alt="Figure 14: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 14: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="if-and-if-else-statments">If and If/Else Statments<a hidden class="anchor" aria-hidden="true" href="#if-and-if-else-statments">#</a></h3>
<p>Now that we have learned about conditional branch and jump instructions, let&rsquo;s implement <em>if</em> and <em>if-else</em> statements—one of the most widely used branching constructs in high-level programming languages.</p>
<h4 id="if-statement">If Statement<a hidden class="anchor" aria-hidden="true" href="#if-statement">#</a></h4>
<p>The <em>if</em> statement can be implemented using conditional branch instructions, as demonstrated in the program below:</p>
<figure>
    <img loading="lazy" src="/ox-hugo/if_state.png"
         alt="Figure 15: If Statement"/> <figcaption>
            <p><span class="figure-number">Figure 15: </span>If Statement</p>
        </figcaption>
</figure>

<p>In the program, if the values in registers <code>x5</code> and <code>x6</code> are not equal, the execution jumps to the branch label <em>NEQUAL</em>. This means the instructions immediately following the condition are skipped, and the program continues execution from the labeled section.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/if_state_reg.png"
         alt="Figure 16: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 16: </span>Register Values</p>
        </figcaption>
</figure>

<h4 id="if-else-statement">If/Else Statement<a hidden class="anchor" aria-hidden="true" href="#if-else-statement">#</a></h4>
<p>Similar to the <em>if</em> statement, the <em>if-else</em> statement uses conditional branch along with jump instruction to perform the <em>else</em> operation. The program below illustrates the implementation of <em>if-else</em> statement.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/if_else.png"
         alt="Figure 17: If Statement"/> <figcaption>
            <p><span class="figure-number">Figure 17: </span>If Statement</p>
        </figcaption>
</figure>

<p>In this case, if the values in registers <code>x5</code> and <code>x6</code> are equal, the program takes the branch. Otherwise, it continues executing the immediate instructions. The jump instruction <code>j</code> ensures that the branch executes correctly by jumping to the else label, handling the else statement effectively.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/if_else_reg.png"
         alt="Figure 18: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 18: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="case-statement">Case Statement<a hidden class="anchor" aria-hidden="true" href="#case-statement">#</a></h3>
<p>A <em>case</em> statement is another form of the <em>if-else</em> condition commonly used in high-level languages to select an output from multiple input conditions. In RISC-V, <em>case</em> statements are implemented using a combination of conditional branch and jump instructions to efficiently execute the corresponding code block based on the given condition.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/case.png"
         alt="Figure 19: Case Statement"/> <figcaption>
            <p><span class="figure-number">Figure 19: </span>Case Statement</p>
        </figcaption>
</figure>

<p>The program demonstrates a simple 2:1 multiplexer (MUX) implementation using conditional branching. Here, the select line is stored in register <code>x5</code>. The <em>case</em> statement checks for values ranging from 0 to 3, and if the select line matches any of these values, the output is set to select line + 1.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/case_reg.png"
         alt="Figure 20: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 20: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="while-loops">While Loops<a hidden class="anchor" aria-hidden="true" href="#while-loops">#</a></h3>
<p>Loops are a crucial programming construct that allows a piece of code to be executed repeatedly. One of the most commonly used looping structure is the while loop. In assembly, loops are implemented using conditional branching in combination with jump instructions. In the following program, we will explore how to implement a while loop in RISC-V using branch and jump instructions.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/while.png"
         alt="Figure 21: Case Statement"/> <figcaption>
            <p><span class="figure-number">Figure 21: </span>Case Statement</p>
        </figcaption>
</figure>

<p>The program demonstrates a simple counter using branch, jump and arithmetic instructions. The counter is stored in register <code>x6</code>, and it increments until it reaches the value stored in register <code>x5</code>. The <code>beq</code> (branch if equal) instruction checks whether the value in <code>x6</code> is equal to <code>x5</code>. If the values are not equal, the counter <code>x6</code> is incremented by 1, and the loop continues. Once <code>x6</code> reaches <code>x5</code>, the program branches to the label done, exiting the loop.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/while_reg.png"
         alt="Figure 22: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 22: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="for-loop">For Loop<a hidden class="anchor" aria-hidden="true" href="#for-loop">#</a></h3>
<p>Another important looping construct is the for loop, which provides a structured way to repeat a block of code with an initialization, condition check, and iteration step. Let&rsquo;s implement another counter program using a for loop, with a slight variation from the previous example. This version explicitly sets up the loop with an initial value, a condition check, and an increment operation, closely resembling the for loop structure in high-level languages.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/for.png"
         alt="Figure 23: Case Statement"/> <figcaption>
            <p><span class="figure-number">Figure 23: </span>Case Statement</p>
        </figcaption>
</figure>

<p>The program computes the sum of a sequence by repeatedly adding the value of i to sum. The sum is stored in register <code>x7</code>, while the loop variable i is stored in register <code>x6</code>. A branching condition checks whether i has reached the total number of iterations stored in register <code>x5</code>. If i is not equal to <code>x5</code>, the loop continues, adding i to sum and incrementing i. Once i reaches <code>x5</code>, the loop exits, and the final sum is stored in <code>x7</code>.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/for_reg.png"
         alt="Figure 24: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 24: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="function-calls">Function Calls<a hidden class="anchor" aria-hidden="true" href="#function-calls">#</a></h3>
<p>Function calls are an essential design methodology that allows code reuse. In RISC-V, function calls are implemented using the jump and link <code>jal</code> instruction and jump register <code>jr</code> instruction, with the return address <code>ra</code> register storing the return location. The following program demonstrates function calls for simple addition and multiplication operations in RISC-V assembly. These functions take two input values, perform the respective operations, and return the result.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/funct_call.png"
         alt="Figure 25: Function Call"/> <figcaption>
            <p><span class="figure-number">Figure 25: </span>Function Call</p>
        </figcaption>
</figure>

<p>In Figure 25, the right side displays the memory address corresponding to each instruction. This helps visualize how instructions are stored and executed sequentially. Figure 26 illustrates the register values after executing the function. Notably, the return address <code>ra</code> register holds the value <strong>14</strong>, which corresponds to the next instruction after the function call. This ensures that after executing the function, the program resumes execution from the correct point. This way the jump and link <code>jal</code>, jump register <code>jr</code>, and return address <code>ra</code> register to manage program flow efficiently.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/funct_call_reg.png"
         alt="Figure 26: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 26: </span>Register Values</p>
        </figcaption>
</figure>

<h3 id="stack">Stack<a hidden class="anchor" aria-hidden="true" href="#stack">#</a></h3>
<p>The <strong>stack</strong> is a crucial memory element in a processor, primarily used for storing register contents when a program exhausts resources or during a function call, where register values need to be saved before modification. The <strong>stack pointer</strong> <code>sp</code> points to the address of the stack. Unlike regular memory storage, where addresses increase as data is stored, the stack follows a <em>last-in, first-out (LIFO)</em> principle. The stack pointer starts at the highest memory address and decrements as data is pushed onto the stack. This mechanism ensures that temporary data, such as function arguments and return addresses, are efficiently stored and retrieved, making function calls and resource management efficient.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/stack.png"
         alt="Figure 27: Stack for Storing Register Values"/> <figcaption>
            <p><span class="figure-number">Figure 27: </span>Stack for Storing Register Values</p>
        </figcaption>
</figure>

<p>The example program used in fucntion call is modified  to save the register contents onto the stack before performing the arithmetic operation. Figure 27 illustrates the use of the save <code>sw</code> and load <code>lw</code> instructions to store and retrieve register values from the stack. Before storing any data, it is essential to allocate the required memory space on the stack. This is done by decrementing the stack pointer <code>sp</code> by 8, ensuring enough space to store two 32-bit values.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/stack_reg.png"
         alt="Figure 28: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 28: </span>Register Values</p>
        </figcaption>
</figure>

<p>Figure 29, shows the contents of the stack memory. The register value <code>x6</code> and <code>x7</code> are stored in the addresses 0x7FFF_FFEC and 0x7FFF_FFE8 respectively.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/stack_mem.png"
         alt="Figure 29: Stack Memory"/> <figcaption>
            <p><span class="figure-number">Figure 29: </span>Stack Memory</p>
        </figcaption>
</figure>

<h4 id="recursive-function">Recursive Function<a hidden class="anchor" aria-hidden="true" href="#recursive-function">#</a></h4>
<p>One of the classic examples of a recursive function is computing the factorial of a number. Recursion is a powerful concept where a function calls itself to break down a problem into smaller subproblems. Below, we first implement the factorial function in C, followed by its equivalent RISC-V assembly implementation, demonstrating how recursion is handled at the low level.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fact</span> (<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (n <span style="color:#f92672">*</span> <span style="color:#a6e22e">fact</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let’s take an example where n = 4, and the function fact(4) is called. The <em>if</em> condition checks whether n is less than or equal to 1. If true, it returns 1. Otherwise, the else condition is executed, which returns the multiplication of n * fact(n-1).</p>
<p>For n = 4, the function returns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">fact</span>(<span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>This process continues recursively until n-1 reaches the base case (n = 1). At this point, the recursive calls begin to resolve, forming the expression:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>(<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span>))))
</span></span></code></pre></div><p>Figure 30 illustrates the assembly implementation of a recursive function. To ensure the recursion works effectively, it is necessary to store the return address <code>ra</code> and any registers that will be modified on the stack before making repeated function calls. In this example, the register <code>x5</code> is saved on the stack along with <code>ra</code> before each recursive call. This preserves the previous values, allowing the function to return correctly once the recursion starts unfolding.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/fact.png"
         alt="Figure 30: Factorial Program"/> <figcaption>
            <p><span class="figure-number">Figure 30: </span>Factorial Program</p>
        </figcaption>
</figure>

<p>Figure 31, shows the register values of the program, the register <code>x5</code> hold the result of the factorial.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/fact_reg.png"
         alt="Figure 31: Register Values" width="200px"/> <figcaption>
            <p><span class="figure-number">Figure 31: </span>Register Values</p>
        </figcaption>
</figure>

<p>Figure 32 illustrates the stack memory layout during a recursive function call. The memory address 0x7FFF_FFEC holds the return address <code>ra</code> register, while 0x7FFF_FFE8 stores the value of register <code>x5</code>. Each time a function call occurs, the current return address and register values are pushed onto the stack, ensuring they can be restored once the function completes and returns.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/fact_mem.png"
         alt="Figure 32: Stack Memory"/> <figcaption>
            <p><span class="figure-number">Figure 32: </span>Stack Memory</p>
        </figcaption>
</figure>



  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/riscv/">Riscv</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
