<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>sv on Home</title>
    <link>https://24x7fpga.com/tags/sv/</link>
    <description>Recent content in sv on Home</description>
    <generator>Hugo -- 0.121.1</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Jul 2024 17:27:00 -0400</lastBuildDate>
    <atom:link href="https://24x7fpga.com/tags/sv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Disable Fork</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_23_17_27_50_disable_fork/</link>
      <pubDate>Tue, 23 Jul 2024 17:27:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_23_17_27_50_disable_fork/</guid>
      <description>SV Verification Directory
Disable Fork The disable fork contruct will terminate all outstanding or active processes when it is executed.
Syntax: Disable Fork fork // process 1 // process 2 // process 3 join disable fork; Example Code: Disable Fork module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none disable fork; $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Wait Fork</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_23_17_27_07_wait_fork/</link>
      <pubDate>Tue, 23 Jul 2024 17:27:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_23_17_27_07_wait_fork/</guid>
      <description>SV Verification Directory
Wait Fork The wait fork statement is used to wait until all the forked processes is completed.
Syntax: Wait Fork fork // process 1 // process 2 // process 3 join_none // (join, join_any) wait fork; Example Code: Wait Fork module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none wait fork; $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Fork Join None</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_22_11_00_fork_join_none/</link>
      <pubDate>Sat, 20 Jul 2024 22:11:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_22_11_00_fork_join_none/</guid>
      <description>SV Verification Directory
Fork Join None As the name suggests, the process in the fork will start and does not wait till it completes any of the threads. The figure below depicts the fork join none constructs.
Syntax: Fork Join None fork // process 1 // process 2 // process 3 join_none Example Code: Fork Join None module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_none $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule </description>
    </item>
    <item>
      <title>Fork Join Any</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_21_58_50_fork_join_any/</link>
      <pubDate>Sat, 20 Jul 2024 21:58:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_21_58_50_fork_join_any/</guid>
      <description>SV Verification Directory
Fork Join Any Fork join any construct is similar to Fork Join but the simulation process does not wait till all the threads are completed. It proceeds to the next execution statement as soon as any one of the threads completes the process.
Fork join any is depicted in the figure below.
Syntax: Fork Join Any fork // process 1 // process 2 // process 3 join_any Example Code: Fork Join Any module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Fork Join</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_21_47_05_fork_join/</link>
      <pubDate>Sat, 20 Jul 2024 21:47:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_21_47_05_fork_join/</guid>
      <description>SV Verification Directory
Fork Join A thread or a process is a block of code that execute sequentially. They are created using constructs like initial blocks, always blocks, and tasks. In verification there are multiple components, such as generator, driver, monitor, etc, these components have multiple threads that need to run concurrently, allowing for parallel execution of different parts of the simulation. The fork-join construct is created to run multiple procedural threads to run in parallel.</description>
    </item>
    <item>
      <title>Functions</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_15_36_43_functions/</link>
      <pubDate>Sat, 20 Jul 2024 15:36:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_15_36_43_functions/</guid>
      <description>SV Verification Directory
Functions A function must return a value. A function should not include delays, event controls, or wait statements. A function can only contain inputs as arguments as it returns only one output value. Similar to tasks:
A function can be declared as automatic or static. It can contain static variables in automatic function and vice-versa. Syntax: Function function [return type] function_name (input_arguments); // execute the code return [value]; endfunction Example Code: Function module function_ex; function int mul_3(int x); return x*3; endfunction initial begin int x; $display(&amp;#34;---------- Multiply by 3 ----------&amp;#34;); repeat(20)begin x = $urandom_range(1,9); $display(&amp;#34;x = %0d, mul_by_3 = %0d&amp;#34;, x, mul_3(x)); end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Tasks</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_15_48_23_tasks/</link>
      <pubDate>Fri, 19 Jul 2024 15:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_15_48_23_tasks/</guid>
      <description>SV Verification Directory
Tasks Task in SystemVerilog is a procedural block that contains a block of code that can be reused. Unlike [Functions], tasks can contain simulation time. The default port direction is &amp;ldquo;input&amp;rdquo; unless declared as other types. The default data type of the ports is of &amp;ldquo;logic&amp;rdquo; type unless specified. A task does not need to have a &amp;ldquo;begin &amp;hellip; end&amp;rdquo; statement.
Syntax: Task task task_name (in1, in2, in3, output logic out1); // execute the code endtask Example Code: Task module task_ex; logic [3:0] data; logic [3:0] arry[16]; task incr([3:0] in, output logic [3:0] out); out = in + 1; endtask initial begin data = 0; $display(&amp;#34;--------- Task: Increment ---------&amp;#34;); //$display(&amp;#34;data = %0d&amp;#34;, data); arry[0]= data; for(int i=0; i&amp;lt;15; i++)begin incr(arry[i], arry[i+1]); $display(&amp;#34;data = %0d&amp;#34;, arry[i+1]); #1; end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Break and Continue</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</link>
      <pubDate>Fri, 19 Jul 2024 15:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</guid>
      <description>SV Verification Directory
Break and Continue Break and continue in SytemVerilog is used to control the loops. When a &amp;ldquo;break&amp;rdquo; statement is encounted, the loop is terminated and control moves to outside of the loop. Whereas, when a &amp;ldquo;continue&amp;rdquo; statement is encounted, the consecutive blocks of code is skipped and the control is moved to the next loop iteration value.
Example Code: Break and Continue module break_and_continue; initial begin int i = 0; $display(&amp;#34;---------- Even Number ----------&amp;#34;); forever begin if(i % 2 == 0) begin $display(&amp;#34;%0d is an Even Number&amp;#34;, i); i = i + 1; continue; end else begin if(i &amp;gt; 20) break; end i = i + 1; #1; end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Repeat and Forever</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</link>
      <pubDate>Fri, 19 Jul 2024 14:46:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</guid>
      <description>SV Verification Directory
Repeat and Forever Loops The &amp;ldquo;repeat&amp;rdquo; and &amp;ldquo;forever&amp;rdquo; loops are another looping constructs available constructs in SystemVerilog, to execute a loop of code for a specific number of times or indefinitely. These loops are especially useful in testbenches and design verification when you need controlled or infinite iterations.
Repeat The repeat loop executes a block of code a specified number of times. This loop is handy when you know the exact number of iterations required.</description>
    </item>
    <item>
      <title>While and Do While Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</link>
      <pubDate>Fri, 19 Jul 2024 14:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</guid>
      <description>SV Verification Directory
While and Do While While and do while loops are used for iterative control structures that execute a block of code multiple times based on a condition. These loops are particularly useful when the number of iterations is not known beforehand and depends on the evaluation of the loop condition.
While Loop The &amp;ldquo;while&amp;rdquo; loop executes a block code until the specified condition is true. The condition is evaluated before each iteration.</description>
    </item>
    <item>
      <title>For and Foreach Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</link>
      <pubDate>Fri, 19 Jul 2024 12:40:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</guid>
      <description>SV Verification Directory
For and Foreach Loops Loops are essential constructs to repeat a block of code for a specified amount of time. SystemVerilog provides two constructs to itreate over a range of elements and they are &amp;ldquo;for&amp;rdquo; loop and &amp;ldquo;foreach&amp;rdquo; loop.
For Loop Similar to other programming languages, the &amp;ldquo;for&amp;rdquo; loop in SystemVerilog repeats a block of code for a specified number of times. Ideal for controlled, indexed iterations where the number of iterations is known beforehand.</description>
    </item>
    <item>
      <title>Dynamic Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:41:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</guid>
      <description>SV Verification Directory
Dynamic Cast The dynamic cast, $cast, allows you to check for out-of-bounds values. Use dynamic cast when converting from a type with a large number of values than the destination, such as int to en enumerated variables.</description>
    </item>
    <item>
      <title>Static Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:32:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</guid>
      <description>SV Verification Directory
Static Cast The static cast operation converts between two types with no checking of values. Specify the destination type, an apostrophe, and the expression to be converted as shown below:
int i; real r; i = int &amp;#39;(75.0); r = real &amp;#39;(75); </description>
    </item>
    <item>
      <title>Structures</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</link>
      <pubDate>Tue, 02 Jul 2024 16:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</guid>
      <description>SV Verification Directory
Structure One of the biggest limitations of Verilog is the lack of data structures. In SystemVerilog, you can create a structure using the struct statement. A structure is a collection of data that can be synthesized.
Example of struct:
struct {logic [7:0] data_a, data_b, data_c;} data_s; data_s in_data; NOTE: By default a structure is unpacked.
Typedef for Struct To create multiple structure variables it is necessary to use typedef data type.</description>
    </item>
    <item>
      <title>Enumeration</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</link>
      <pubDate>Tue, 02 Jul 2024 15:05:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</guid>
      <description>SV Verification Directory
Enumeration In Verilog, it is possible to declare user-defined types using a define macro, shown below:
`define TYPE1 8 `define TYPE2 32 This does not create a new type but just performance text substitution. In SystemVerilog, a new type can be created with the following code:
typedef logic [Size-1:0] VAR_T; VAR_T var1, var2; The typedef and parameter statements can be put in a package so they can be shared across the design and testbench.</description>
    </item>
    <item>
      <title>Array Methods</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</link>
      <pubDate>Tue, 02 Jul 2024 09:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</guid>
      <description>SV Verification Directory
Array Methods Array methods are generic manipulation methods that apply to the entire array rather than iterating to every element in the array.
Basic Array Operations Copy: an array can be copied completely to another array without using a loop statement. Compare: two arrays can be compared for equality and inequality. Keep in mind that two arrays that are being compared or copied must be of the same base type and size.</description>
    </item>
    <item>
      <title>Associative Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</link>
      <pubDate>Tue, 02 Jul 2024 00:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</guid>
      <description>SV Verification Directory
Associative Arrays Associative arrays in SystemVerilog allow you to index arrays with arbitrary data types. An associative array can be stored by the simulator as a tree or a hash table. An associative array is declared with a data type in square brackets. Only the elements that are explicitly assigned are stored, making it memory-efficient for sparse arrays.
Example of associative arrays in SV is shown below:</description>
    </item>
    <item>
      <title>Queues</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</link>
      <pubDate>Mon, 01 Jul 2024 23:35:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</guid>
      <description>SV Verification Directory
Queues Queue is a new data type introduced in SystemVerilog that combines the best of a linked list and an array.
Like a linked list, elements can be added and removed anywhere in the queue, without performance degradation when using a dynamic array that has to allocate a new array and copy the entire contents. Like an array, any element in the queue can be directly accessed with the help of the index, without the linked list&amp;rsquo;s overhead of stepping through the preceding element.</description>
    </item>
    <item>
      <title>Dynamic Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</link>
      <pubDate>Mon, 01 Jul 2024 15:56:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</guid>
      <description>SV Verification Directory
Dymanic Arrays Dynamic arrays are arrays that do not have their size set during the compile time. They can be allocated and resized during simulation based on the design requirement so that the simulation cosumes minimal amount of memory. A dynamic array can be declare with empty word subscripts &amp;ldquo;[ ]&amp;rdquo;. The array is initially empty and must be called with the &amp;ldquo;new[ ]&amp;rdquo; constuctor to allocate space, passing in the number of entries in the square brackets.</description>
    </item>
    <item>
      <title>Packed and Unpacked Array</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</link>
      <pubDate>Sat, 29 Jun 2024 23:39:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</guid>
      <description>SV Verification Directory
Packed and Unpacked Array Packed and unpacked arrays are differentiated based on the way the arrays are stored in the memory. Generally, simulators store each element on a 32-bit word boundary. In a packed array, the elements are stored in contiguous memory locations whereas in an unpacked array, the elements are not stored in contiguous memory locations.
Packed Array A packed array can be declared by declaring the dimension before the identifier name shown below:</description>
    </item>
    <item>
      <title>Fixed-Size Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</link>
      <pubDate>Sat, 29 Jun 2024 23:25:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</guid>
      <description>SV Verification Directory
Fixed-Size Arrays An array is a collection of elements stored sequentially. An array in Verilog should be declared with upper and lower bounds. The lower bound in most of the arrays is zero. Fixed-size arrays have constant size and do not change during run time. The array size is set at compile time.
Single Dimension Array There are two ways in SystemVerilog to declare single-dimension arrays which are shown below:</description>
    </item>
    <item>
      <title>Logic Type</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</link>
      <pubDate>Fri, 28 Jun 2024 14:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</guid>
      <description>SV Verification Directory
Logic Type Data Types SystemVerilog includes all the data types that are available with Verilog and add many new data types to help both hardware design engineers and verification engineers. Below is a table showing an extensive list of data types availabe in SystemVerilog.
Language Data Type State Type No. of Bits Signed/Unsigned C Equivalent SystemVerilog/Verilog Wire 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Reg 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Interger 4 32 Signed - SystemVerilog/Verilog Real 2 Double Precision Floating point Double SystemVerilog/Verilog Time 4 64 Unsigned - SystemVerilog Logic 4 &amp;gt;=1 unsigned - SystemVerilog Bit 2 &amp;gt;=1 unsigned - SystemVerilog Byte 2 8 Signed Char SystemVerilog Int 2 32 Signed Int SystemVerilog Shortint 2 16 Signed Short Int SystemVerilog Longint 2 64 Signed Long Int Note: signed variables can cause unexpected results with randomization.</description>
    </item>
  </channel>
</rss>