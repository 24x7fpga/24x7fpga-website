<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Home</title>
    <link>https://24x7fpga.com/</link>
    <description>Recent content on Home</description>
    <generator>Hugo -- 0.121.1</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Sep 2024 14:44:00 -0400</lastBuildDate>
    <atom:link href="https://24x7fpga.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UVM Workflow in Vivado</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_04_14_44_52_uvm_workflow_in_vivado/</link>
      <pubDate>Wed, 04 Sep 2024 14:44:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_04_14_44_52_uvm_workflow_in_vivado/</guid>
      <description>UVM &amp;ndash; UVM Vivado Script &amp;ndash; UVM Python Script
The UVM (Universal Verification Methodology) workflow is centered around creating a testbench that integrates key UVM components such as drivers, monitors, and scoreboards, alongside the essential UVM library setup. Numerous commercial tools are available for simulating and verifying digital designs, including ModelSim, Cadence Xcelium, Synopsys VCS, Aldec Riviera-PRO, and Vivado Simulator. Another excellent option for experimenting with small-to-medium-sized verification projects is EDA Playground.</description>
    </item>
    <item>
      <title>UVM Framework Directory</title>
      <link>https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory/</link>
      <pubDate>Wed, 28 Aug 2024 12:39:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory/</guid>
      <description>UVM stands for Universal Verification Method developed by UVM Working Group that provides a standardized methodology for verifying digital integrated circuits. UVM is built on top of SystemVerilog and provides a useful framework for creating reusable and scalable testbenchs. The framework provides a set of building blocks or pre-built design kits that help to create a complex system in a more organized and efficient way instead of building everything from scratch.</description>
    </item>
    <item>
      <title>Synchronous FIFO</title>
      <link>https://24x7fpga.com/rtl_directory/2024_08_22_14_57_15_synchronous_fifo/</link>
      <pubDate>Thu, 22 Aug 2024 14:57:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_08_22_14_57_15_synchronous_fifo/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Synchronous FIFO A FIFO (First-In-First-Out) is a storage buffer that is widely used in digital systems where the data that is stored in the memory is retrieved first, hence the name FIFO.
A synchronous FIFO is a type of FIFO where the write and read operations are synchronized with the same clock signal.
Figure 1: FIFO Buffer
The data retrieval is based on the order of the data written to the FIFO buffer.</description>
    </item>
    <item>
      <title>Clocking Block</title>
      <link>https://24x7fpga.com/sv_directory/2024_08_08_13_51_50_clocking_block/</link>
      <pubDate>Thu, 08 Aug 2024 13:51:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_08_08_13_51_50_clocking_block/</guid>
      <description>SV Verification Directory
Clocking Block Clocking block in a testbench is implemented to manage timing relationship and synchronization for a group signals. t provides a clear and organized way to define the clocking events, control the sampling and driving of signals, and synchronize operation.
Groups signals under a common clock, specifying how and when signals are sampeld and driven with respect the clock. Provide specification to model clock skew for input and output.</description>
    </item>
    <item>
      <title>Interface</title>
      <link>https://24x7fpga.com/sv_directory/2024_08_08_10_27_00_interface/</link>
      <pubDate>Thu, 08 Aug 2024 10:27:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_08_08_10_27_00_interface/</guid>
      <description>SV Verification Directory
Interface Interface in SystemVerilog is a construct that bundles all the signals together or group related signals so that they can be shared among multiple modules in the verification environment. This simplifies the connection between modules, improves code readability, and reduces the likelihood of errors in complex designs.
Syntax // create interface interface interface_name; signals; endinterface // intantiate interface in a module inteface_name inst_name; Example Code Design</description>
    </item>
    <item>
      <title>Modport</title>
      <link>https://24x7fpga.com/sv_directory/2024_08_08_10_17_52_modport/</link>
      <pubDate>Thu, 08 Aug 2024 10:17:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_08_08_10_17_52_modport/</guid>
      <description>SV Verification Directory
Modport The modport construct within an interface module is used to group signals and specify their directionality. By assigning port directions, modport enforces access control, restricting signals to specific roles and clearly defining their intended function within the interface.
The modport keyword is employed to establish these signal definitions within an interface.
Modport provides input, output, inout and ref as port declarations. Signals that are driven should be declared as outputs in the modport module.</description>
    </item>
    <item>
      <title>RFSoC Loop Back Tutorial</title>
      <link>https://24x7fpga.com/rfsoc_directory/2024_08_07_22_15_09_rfsoc_loop_back_tutorial/</link>
      <pubDate>Wed, 07 Aug 2024 22:15:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rfsoc_directory/2024_08_07_22_15_09_rfsoc_loop_back_tutorial/</guid>
      <description>RFSoC
RFSoC Loop Back Tutorial Figure 1: Zynq UltraScale+ RFSoC 1275 Characterization Kit
RF Data Converter IP Each RFSoC offers multiple RF-ADCs and RF-DACs which are high precision, high speed, and power efficient. Xilinx Vivado is equipped with RF Data Converter IP core which provides a configurable wrapper that allows these RF-ADCs and RF-DACs blocks to be used in the IP integrator designs. The RF-ADCs and RF-DACs are organized into tiles where each tiles contains one, two or four RF-ADCs and RF-DACs.</description>
    </item>
    <item>
      <title>RFSoC</title>
      <link>https://24x7fpga.com/rfsoc_directory/2024_08_07_22_09_59_rfsoc/</link>
      <pubDate>Wed, 07 Aug 2024 22:09:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rfsoc_directory/2024_08_07_22_09_59_rfsoc/</guid>
      <description>RFSoC RFSoC Loop Back Tutorial RFSoC External Clock and Data RFSoC MTS Tutorial </description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://24x7fpga.com/sv_directory/2024_08_06_12_53_53_semaphore/</link>
      <pubDate>Tue, 06 Aug 2024 12:53:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_08_06_12_53_53_semaphore/</guid>
      <description>SV Verification Directory
Interprocess communication is a way to communicate between different processes and testbench components. There are three mechanisms:
Events Mailbox Semaphore Semaphore A semaphore in SystemVerilog is a built-in class used for synchronization. It acts as a container holding a fixed number of keys, which regulate access to shared memory resources. Semaphores are specifically designed to manage and control concurrent access, ensuring that multiple processes can safely interact with shared resources without conflicts.</description>
    </item>
    <item>
      <title>Mailbox</title>
      <link>https://24x7fpga.com/sv_directory/2024_08_06_10_48_02_mailbox/</link>
      <pubDate>Tue, 06 Aug 2024 10:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_08_06_10_48_02_mailbox/</guid>
      <description>SV Verification Directory
Interprocess communication is a way to communicate between different processes and testbench components. There are three mechanisms:
Events Mailbox Semaphore Mailbox A mailbox serves as a synchronization primitive utilized for exchanging data between processes within a testbench. This data, referred to as a message, is managed through the mailbox primitive. A process intending to send data places (puts) the message into the mailbox, where it is temporarily stored in system-defined memory.</description>
    </item>
    <item>
      <title>Always@(*) and Always_Comb</title>
      <link>https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/</link>
      <pubDate>Mon, 05 Aug 2024 16:05:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Always@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we&amp;rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.</description>
    </item>
    <item>
      <title>Git Sync a Forked Repository</title>
      <link>https://24x7fpga.com/git_directory/2024_08_04_14_34_41_git_sync_a_forked_repository/</link>
      <pubDate>Sun, 04 Aug 2024 14:34:00 -0400</pubDate>
      <guid>https://24x7fpga.com/git_directory/2024_08_04_14_34_41_git_sync_a_forked_repository/</guid>
      <description>Reference Video
Git Sync a Forked Repository To sync a forked repository with the upstream repository (the original repository from which you forked), you can follow these steps:
Add the parent repository/upstream repository if not already added: git remote add {upstream/parent} {ssh original git repo} {upstream/parent} is user defined the name given to the original repo. Once the original repository is added, Git Pull the original repository to the local repository: git pull {upstram/parent} {branch} {branch} is the name of the branch, it could be main or the branch name you want to sync the local repository.</description>
    </item>
    <item>
      <title>Git Pull</title>
      <link>https://24x7fpga.com/git_directory/2024_08_04_12_24_44_git_pull/</link>
      <pubDate>Sun, 04 Aug 2024 12:24:00 -0400</pubDate>
      <guid>https://24x7fpga.com/git_directory/2024_08_04_12_24_44_git_pull/</guid>
      <description>Git Pull Documentation
Git Pull Git pull is used to sync up the local repository with the remote repository. This command performs two operation:
[Git Fetch]: will download the contents from the remote repository. [Git Rebase] or [Git Merge]: will update the local repository with the remote repository. </description>
    </item>
    <item>
      <title>Events</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_31_17_20_12_events/</link>
      <pubDate>Wed, 31 Jul 2024 17:20:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_31_17_20_12_events/</guid>
      <description>SV Verification Directory
Interprocess communication is a way to communicate between different processes and testbench components. There are three mechanisms:
Events Mailbox Semaphore Events Events are static objects in SystemVerilog, used to synchronize different testbench components. The events are triggered using -&amp;gt; or -&amp;gt;&amp;gt; and the process can wait for the event to be triggered using @ operator or wait() construct.
Event Description - &amp;gt; Blocking events, also know as instanteous event, block the process untill the event is triggered.</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_31_16_19_14_encapsulation/</link>
      <pubDate>Wed, 31 Jul 2024 16:19:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_31_16_19_14_encapsulation/</guid>
      <description>SV Verification Directory
Encapsulation Encapsulation is a technique used to restrict access to the data and methods within a class, ensuring that internal class details are not accessible from outside the class.
Access Specifiers These define the visibility of class members and they are as follows:
Local Members declared as local are accessible only within the class itself.
Syntax
class ex; local int a; function new(); // execute code endfunction endclass Protected Members declared as protected are accessible within the class and its derived classes.</description>
    </item>
    <item>
      <title>Polymorphism</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_31_10_26_49_polymorphism/</link>
      <pubDate>Wed, 31 Jul 2024 10:26:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_31_10_26_49_polymorphism/</guid>
      <description>SV Verification Directory
Polymorphism As the term &amp;lsquo;polymorphism&amp;rsquo; implies, &amp;lsquo;poly&amp;rsquo; means &amp;lsquo;many&amp;rsquo; and &amp;lsquo;morph&amp;rsquo; means &amp;lsquo;form&amp;rsquo; or &amp;lsquo;shape&amp;rsquo;. A base class handle can invoke methods of its child class which has the same name. Hence, an object can take many forms.
An extended class object can be assigned to the base class but not the other way round. Virtual Keyword should be used in parent class to override the method by the child class.</description>
    </item>
    <item>
      <title>Virtual Keyword</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_31_10_21_04_virtual_keyword/</link>
      <pubDate>Wed, 31 Jul 2024 10:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_31_10_21_04_virtual_keyword/</guid>
      <description>SV Verification Directory
Virtual Keyword Virtual keyword enables a child class to override a method defined in its parent class. When a virtual keyword is prefixed before a method in the parent class and if the base class handle is pointed to the extended class, then the extended class method handle will get assigned to the base class handle.
Once the virtual keyword is used for the parent class method, all the extended child classes become virtual.</description>
    </item>
    <item>
      <title>Git Checkout</title>
      <link>https://24x7fpga.com/git_directory/2024_07_30_10_18_06_git_checkout/</link>
      <pubDate>Tue, 30 Jul 2024 10:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/git_directory/2024_07_30_10_18_06_git_checkout/</guid>
      <description>Git Checkout Documentation
Git Checkout Git checkout is used to switch or restore branches.
Switch Branch From Git Branch, you can identify the branch name to which you want to switch to.
git checkout &amp;lt;branch&amp;gt; </description>
    </item>
    <item>
      <title>Git Branch</title>
      <link>https://24x7fpga.com/git_directory/2024_07_30_09_58_52_git_branch/</link>
      <pubDate>Tue, 30 Jul 2024 09:58:00 -0400</pubDate>
      <guid>https://24x7fpga.com/git_directory/2024_07_30_09_58_52_git_branch/</guid>
      <description>Git Branch Documentation
Git Branch Display Local Branches Displays local branches. The (*) asterisk symbol next to branch indicates the current branch.
git branch Display Remote Branches Displays remote branches, i.e., branches hosted on the remote repositories.
git branch --remote // displays only remote repo git branch -a // displays remote and local repo Checking Remote Repository Information Provides remote repository information such as repository structure, configuration and branches.
git remote show origin </description>
    </item>
    <item>
      <title>Super Keyword</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_29_12_16_52_super_keyword/</link>
      <pubDate>Mon, 29 Jul 2024 12:16:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_29_12_16_52_super_keyword/</guid>
      <description>SV Verification Directory
Super Keyword The super keyword is useful for accessing the properties and methods of a parent class without needing to declare a parent class handle. It consistently refers to the immediate parent class.
By default, SystemVerilog complier calls super.new() function calls automatically from extende class.
When the class method require input arguments, the the user has to call super.new{arguments} explicitly.
Note: super.super.{class_member} is not allowed to access multilevel inheritance.</description>
    </item>
    <item>
      <title>Inheritance</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_29_11_09_50_inheritance/</link>
      <pubDate>Mon, 29 Jul 2024 11:09:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_29_11_09_50_inheritance/</guid>
      <description>SV Verification Directory
Inheritance Inheritance allows a new class to inherit properties and methods from an existing class.
Creates an extended class from an existing class. The existing class is called as base class or parent class and the extended class is called as the derived class or the child class. The extends keyword is used to inherit the properties of the parent class to the child class. Multilevel inheritance is possible in SystemVerilog i.</description>
    </item>
    <item>
      <title>Four Pillars of OOP</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_29_10_30_53_four_pillars_of_oop/</link>
      <pubDate>Mon, 29 Jul 2024 10:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_29_10_30_53_four_pillars_of_oop/</guid>
      <description>SV Verification Directory
Four Pillars of OOP The are four pillars of Object-Oriented Programming (OOP) are:
Abstraction Encapsulation Inheritance Polymorphism Abstraction Abstraction is the concept of hiding the complex implementation details and showing only the essential features of the object. It allows users to interact with objects through a simplified interface, without needing to understand the underlying complexity.
Encapsulation This principle involves bundling the data (attributes) and the methods (functions) that operate on the data into a single unit called an object.</description>
    </item>
    <item>
      <title>Vivado Installation</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_28_10_50_56_vivado_installation/</link>
      <pubDate>Sun, 28 Jul 2024 10:50:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_28_10_50_56_vivado_installation/</guid>
      <description>Digilent&amp;rsquo;s Zybo-Z7 is a ready-to-use embedded software and digital circuit development board built around the Xilinx Zynqâ„¢-7000 family. Xilinx provides free licensing to certain development boards and Zybo-Z7 is one among them. This article provides detailed steps to install Vivado 2022.2 on Ubuntu 22.04 LTS. The same procedure can be followed to install the desired version of the software.
Initial Requirements A desktop/laptop with at least 16GB of RAM (DDR4 preferred) and 100GB of free storage space for full installation.</description>
    </item>
    <item>
      <title>Blocking and Non-Blocking Assignment</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_26_17_10_23_blocking_and_non_blocking_assignment/</link>
      <pubDate>Fri, 26 Jul 2024 17:10:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_26_17_10_23_blocking_and_non_blocking_assignment/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Blocking and Non-Blocking Assignment Let us model a simple design that is given in Figure 1 in Verilog. There are many ways to optimally model the design but here we will learn the difference between blocking and non-blocking assignments in Verilog.
Boolean Equation We will model our design based on the equations given below.
x = a and b y = x xor c z = y Figure 1: Digital Logic</description>
    </item>
    <item>
      <title>Assign and If-Else Statement</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_26_17_07_08_assign_and_if_else_statement/</link>
      <pubDate>Fri, 26 Jul 2024 17:07:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_26_17_07_08_assign_and_if_else_statement/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Assign Statement The &amp;lsquo;assign&amp;rsquo; statement is used to model combinational logic by creating continuous assignments. It is typically implemented where the output continuously reflects the changes in the input without any delay. The assign statement is used with signals declared as wire, tri, or other net types, but not with reg types. However, in SystemVerilog, logic type can be used in continuous assignments, similar to wire.</description>
    </item>
    <item>
      <title>Full Case and Parallel Case</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_26_17_05_01_full_case_and_parallel_case/</link>
      <pubDate>Fri, 26 Jul 2024 17:05:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_26_17_05_01_full_case_and_parallel_case/</guid>
      <description>[Design] &amp;ndash; [Testbench] &amp;ndash; RTL Design Directory
Full Case and Parallel Case The case statement is a fundamental construct used for conditional branching across various programming languages. In SystemVerilog, it is implemented as a simple if-else-if statement. SystemVerilog introduces two specialized variations of the case statement, casex and casez, that allow for handling &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; conditions in the case items, discussed in Casex and Casez.
The case statement can be caterogired as full and parallel based on the how the case items are being matched to case expression.</description>
    </item>
    <item>
      <title>Shallow Copy and Deep Copy</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_26_09_41_22_shallow_copy_and_deep_copy/</link>
      <pubDate>Fri, 26 Jul 2024 09:41:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_26_09_41_22_shallow_copy_and_deep_copy/</guid>
      <description>SV Verification Directory
Shallow Copy and Deep Copy SystemVerilog provides two means of copying or duplicating objects to keep a method from modifying the original. The two methods are shallow copy and deep copy, and understanding these methods is crucial for effective memory management.
Shallow Copy Shallow copy is a method where the objects are duplicated to a new memory location. If the class contains a handle to another class, only the handle&amp;rsquo;s value is copied not the lower level object, meaning both the original and copied object share the same instances of nested objects.</description>
    </item>
    <item>
      <title>Static Class Properties and Methods</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_25_14_51_44_static_class_properties_and_methods/</link>
      <pubDate>Thu, 25 Jul 2024 14:51:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_25_14_51_44_static_class_properties_and_methods/</guid>
      <description>SV Verification Directory
Static Class Properties and Methods Every object has its own local variables that are not shared with any other object. When two objects of Ex_class Class is created, each object with have its own class properties(variables). In certain instances, a specific variable is required to be shared by all objects of a certain type. Declaring a global variable will make the variable visible to the entire testbench. With the OOP, a static variable can be created inside a class.</description>
    </item>
    <item>
      <title>This Keyword</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_25_14_49_57_this_keyword/</link>
      <pubDate>Thu, 25 Jul 2024 14:49:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_25_14_49_57_this_keyword/</guid>
      <description>SV Verification Directory
This Keyword In SystemVerilog, this keyword is used within a class to refer to the current instance of that class. It is a way to access the members (attributes and methods) of the current object from within the object&amp;rsquo;s methods. This is particularly useful to distinguish between class attributes and parameters or local variables with the same name. When a variable is declared, SystemVerilog looks in the current scope for it and then in the parent scope until the variable is found.</description>
    </item>
    <item>
      <title>Method</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_25_12_36_42_method/</link>
      <pubDate>Thu, 25 Jul 2024 12:36:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_25_12_36_42_method/</guid>
      <description>SV Verification Directory
Class Methods A class method is a task or a function defined inside the scope of the class. A method in a class uses automatic storage by default.
Example: Methods in a Class class Ex_class; // class properties or variables int a, b, s; // task method task sum (int a,b); s = a + b; $display(&amp;#34;a = %0d , b = %0d, sum s = %0d&amp;#34;, a, b ,s); endtask endclass Defining Methods Outside of Class To keep the code short, and easy to read and understand, it is advisable to keep the class to one &amp;ldquo;page&amp;rdquo; or to the screen of the editor.</description>
    </item>
    <item>
      <title>Casex and Casez</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_25_11_36_52_casex_and_casez/</link>
      <pubDate>Thu, 25 Jul 2024 11:36:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_25_11_36_52_casex_and_casez/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Case Statement: An Overview The case statement is a fundamental construct in any programming language. The case statement selects one of many outputs based on the value of the case expression. It is equicalent to an if-else-if statement.
Syntax case(case expression) case item1 : case statement_1; case item2 : case statement_2; case item3 : case statement_3; ... default : case statement_default; endcase Case Expression: The case statement chooses the case item based on the case expression.</description>
    </item>
    <item>
      <title>Synchronous and Asynchronous Reset</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_25_11_34_45_synchronous_and_asynchronous_reset/</link>
      <pubDate>Thu, 25 Jul 2024 11:34:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_25_11_34_45_synchronous_and_asynchronous_reset/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Synchronous and Asynchronous Reset Resets are crucial in digital circuits for ensuring the system starts from a known state.
Resets allow the system to recover from errors by reinitializing the state. Resets ensure that all flip-flops start from a known state. There are two types of resets based on the reset activation and they are:
Synchronous Reset Asynchronous Reset Synchronous Reset In synchronous reset circuits, the reset signal is synchronized with the clock.</description>
    </item>
    <item>
      <title>Handle</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_24_22_09_00_handle/</link>
      <pubDate>Wed, 24 Jul 2024 22:09:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_24_22_09_00_handle/</guid>
      <description>SV Verification Directory
Handle A handle is a pointer to an object created from a Class. Handles are crucial in dynamically creating and managing Objects during simulation.
Syntax: Handle Ex_class cl_obj; // declare a handle cl_obj = new(); // allocate a Ex_class object When the handle &amp;lsquo;cl_obj&amp;rsquo; is declared, it is initialized to a null value. Call the new() function to construct the Ex_class object. The new function allocates space for Ex_class, initializes the variables to their default values (0 for 2-state and x for 4-state variable), and returns the address where the object is stored.</description>
    </item>
    <item>
      <title>Object</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_24_17_42_06_object/</link>
      <pubDate>Wed, 24 Jul 2024 17:42:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_24_17_42_06_object/</guid>
      <description>SV Verification Directory
Object An object is an instance of a class. It is similar to the instantiation of a module in Verilog, but there are some differences which as listed in the table below:
Verilog Module Instance SystemVerilog Class Instance A module is instantiated during compile time A class is instantiated during simulation when needed by the testbench Verilog instances are static, as hardware does not change during simulation Class objects are created when required and freed from memory when no longer needed The &amp;rsquo;new&amp;rsquo; keyword is used to instantiate the object.</description>
    </item>
    <item>
      <title>Class</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_24_16_47_44_class/</link>
      <pubDate>Wed, 24 Jul 2024 16:47:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_24_16_47_44_class/</guid>
      <description>SV Verification Directory
Class A class is a user-defined data type that serves as a blue-print for creating objects. A class includes properties(variables) and methods(functions and tasks) that manipulate data.
Example: Class class Ex_class; // class properties or variables int a, b, s; // task method task sum (int a,b); s = a + b; $display(&amp;#34;a = %0d , b = %0d, sum s = %0d&amp;#34;, a, b ,s); endtask endclass A class can be defined and used in a program, module, package, or outside of any of these.</description>
    </item>
    <item>
      <title>Object-Oriented Programming</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_24_15_11_27_object_oriented_programming/</link>
      <pubDate>Wed, 24 Jul 2024 15:11:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_24_15_11_27_object_oriented_programming/</guid>
      <description>SV Verification Directory
Object-Oriented Programming Object-oriented Programming(OOP) language model for software design that revolves around objects or data instead of logic and functions. It focuses on what the developers want to manipulate rather than how they manipulate them. This approach is well suited for large, complex, and actively updated and maintained.
OOP for Verification Typically, a testbench creates a transaction i.e., generates the necessary input for the DUT based on the defined rules, transmits it to the DUT, receives the response from the DUT, verifies the response against the golden reference, and generates a report.</description>
    </item>
    <item>
      <title>Throughput and Latency</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_23_21_33_58_throughput_and_latency/</link>
      <pubDate>Tue, 23 Jul 2024 21:33:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_23_21_33_58_throughput_and_latency/</guid>
      <description>Introduction Speed in digital design can have three primary meanings/definitions based on the context of the problem. There are as follows:
Throughput: refers to the amount of time a system takes to process the data per clock cycle, measured in bits per second. Latency: refers to the time between the input and the processed output, measured as clock cycles. Timing: refers to the logic delays between the sequential elements, the standard metric is clock period or frequency.</description>
    </item>
    <item>
      <title>Disable Fork</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_23_17_27_50_disable_fork/</link>
      <pubDate>Tue, 23 Jul 2024 17:27:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_23_17_27_50_disable_fork/</guid>
      <description>SV Verification Directory
Disable Fork The disable fork contruct will terminate all outstanding or active processes when it is executed.
Syntax: Disable Fork fork // process 1 // process 2 // process 3 join disable fork; Example Code: Disable Fork module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none disable fork; $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Wait Fork</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_23_17_27_07_wait_fork/</link>
      <pubDate>Tue, 23 Jul 2024 17:27:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_23_17_27_07_wait_fork/</guid>
      <description>SV Verification Directory
Wait Fork The wait fork statement is used to wait until all the forked processes is completed.
Syntax: Wait Fork fork // process 1 // process 2 // process 3 join_none // (join, join_any) wait fork; Example Code: Wait Fork module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none wait fork; $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Read Only Memory</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_23_13_11_22_read_only_memory/</link>
      <pubDate>Tue, 23 Jul 2024 13:11:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_23_13_11_22_read_only_memory/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Read Only Memory(ROM): An Overview Read-only memory widely known as ROM is a non-volatile memory that is used to store data or programs that do not change over time. As the name suggests, data can only be read from the memory. In digital design, ROM can be used to store image data or signal data for processing.
Memory File A memory file is a simple file with an extension of *.</description>
    </item>
    <item>
      <title>Frequency Divider</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_22_15_24_11_frequency_divider/</link>
      <pubDate>Mon, 22 Jul 2024 15:24:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_22_15_24_11_frequency_divider/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Frequency Divider: An Overview A frequency divider is a digital circuit that reduces the frequency of the main clock by a certain factor. They are typically used in clock generation circuits, timers, counters, etc. Frequency dividers can be categorized into two even and odd frequency dividers based on the factor N. If N is an even number the frequency divider is categorized under an even frequency divider and when N is an odd number it is categorized as an odd frequency divider.</description>
    </item>
    <item>
      <title>Edge Detector</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_22_14_10_16_edge_detector/</link>
      <pubDate>Mon, 22 Jul 2024 14:10:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_22_14_10_16_edge_detector/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Edge Detector: An Overview Edge detectors play a crucial role in synchronous systems to generate a short pulse when a transition of a signal occurs from low to high or high to low. These short pulses are used to trigger an event or generate an interrupt.
There are three types of edge detectors, and they are as follows:
Rising edge detector: detects a signal transition from low to high.</description>
    </item>
    <item>
      <title>Ring Counter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_22_11_17_17_ring_counter/</link>
      <pubDate>Mon, 22 Jul 2024 11:17:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_22_11_17_17_ring_counter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Ring Counter: An Overview A ring counter is a type of shift register that where the output of the last register is fed to the input of the first register forming a type of circular shift register. There are two types of ring counters based on how the last bit is fed to the input and they are:
Simple Ring Counter Twisted Ring Counter Simple Ring Counter A simple ring counter is where the output of the last register is fed to the input of the first register.</description>
    </item>
    <item>
      <title>Fork Join None</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_22_11_00_fork_join_none/</link>
      <pubDate>Sat, 20 Jul 2024 22:11:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_22_11_00_fork_join_none/</guid>
      <description>SV Verification Directory
Fork Join None As the name suggests, the process in the fork will start and does not wait till it completes any of the threads. The figure below depicts the fork join none constructs.
Syntax: Fork Join None fork // process 1 // process 2 // process 3 join_none Example Code: Fork Join None module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_none $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_none $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule </description>
    </item>
    <item>
      <title>Fork Join Any</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_21_58_50_fork_join_any/</link>
      <pubDate>Sat, 20 Jul 2024 21:58:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_21_58_50_fork_join_any/</guid>
      <description>SV Verification Directory
Fork Join Any Fork join any construct is similar to Fork Join but the simulation process does not wait till all the threads are completed. It proceeds to the next execution statement as soon as any one of the threads completes the process.
Fork join any is depicted in the figure below.
Syntax: Fork Join Any fork // process 1 // process 2 // process 3 join_any Example Code: Fork Join Any module fork_join_any; initial begin fork #2 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 1&amp;#34;, $time); #10 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 2&amp;#34;, $time); #5 $display(&amp;#34;t = %0t, fork 1 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 1 ---------------&amp;#34;); end initial begin fork #3 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 1&amp;#34;, $time); #6 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 2&amp;#34;, $time); #1 $display(&amp;#34;t = %0t, fork 2 =&amp;gt; process 3&amp;#34;, $time); join_any $display(&amp;#34;--------------- Exited Fork 2 ---------------&amp;#34;); end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Fork Join</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_21_47_05_fork_join/</link>
      <pubDate>Sat, 20 Jul 2024 21:47:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_21_47_05_fork_join/</guid>
      <description>SV Verification Directory
Fork Join A thread or a process is a block of code that execute sequentially. They are created using constructs like initial blocks, always blocks, and tasks. In verification there are multiple components, such as generator, driver, monitor, etc, these components have multiple threads that need to run concurrently, allowing for parallel execution of different parts of the simulation. The fork-join construct is created to run multiple procedural threads to run in parallel.</description>
    </item>
    <item>
      <title>Functions</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_20_15_36_43_functions/</link>
      <pubDate>Sat, 20 Jul 2024 15:36:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_20_15_36_43_functions/</guid>
      <description>SV Verification Directory
Functions A function must return a value. A function should not include delays, event controls, or wait statements. A function can only contain inputs as arguments as it returns only one output value. Similar to tasks:
A function can be declared as automatic or static. It can contain static variables in automatic function and vice-versa. Syntax: Function function [return type] function_name (input_arguments); // execute the code return [value]; endfunction Example Code: Function module function_ex; function int mul_3(int x); return x*3; endfunction initial begin int x; $display(&amp;#34;---------- Multiply by 3 ----------&amp;#34;); repeat(20)begin x = $urandom_range(1,9); $display(&amp;#34;x = %0d, mul_by_3 = %0d&amp;#34;, x, mul_3(x)); end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Tasks</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_15_48_23_tasks/</link>
      <pubDate>Fri, 19 Jul 2024 15:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_15_48_23_tasks/</guid>
      <description>SV Verification Directory
Tasks Task in SystemVerilog is a procedural block that contains a block of code that can be reused. Unlike [Functions], tasks can contain simulation time. The default port direction is &amp;ldquo;input&amp;rdquo; unless declared as other types. The default data type of the ports is of &amp;ldquo;logic&amp;rdquo; type unless specified. A task does not need to have a &amp;ldquo;begin &amp;hellip; end&amp;rdquo; statement.
Syntax: Task task task_name (in1, in2, in3, output logic out1); // execute the code endtask Example Code: Task module task_ex; logic [3:0] data; logic [3:0] arry[16]; task incr([3:0] in, output logic [3:0] out); out = in + 1; endtask initial begin data = 0; $display(&amp;#34;--------- Task: Increment ---------&amp;#34;); //$display(&amp;#34;data = %0d&amp;#34;, data); arry[0]= data; for(int i=0; i&amp;lt;15; i++)begin incr(arry[i], arry[i+1]); $display(&amp;#34;data = %0d&amp;#34;, arry[i+1]); #1; end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Break and Continue</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</link>
      <pubDate>Fri, 19 Jul 2024 15:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</guid>
      <description>SV Verification Directory
Break and Continue Break and continue in SytemVerilog is used to control the loops. When a &amp;ldquo;break&amp;rdquo; statement is encounted, the loop is terminated and control moves to outside of the loop. Whereas, when a &amp;ldquo;continue&amp;rdquo; statement is encounted, the consecutive blocks of code is skipped and the control is moved to the next loop iteration value.
Example Code: Break and Continue module break_and_continue; initial begin int i = 0; $display(&amp;#34;---------- Even Number ----------&amp;#34;); forever begin if(i % 2 == 0) begin $display(&amp;#34;%0d is an Even Number&amp;#34;, i); i = i + 1; continue; end else begin if(i &amp;gt; 20) break; end i = i + 1; #1; end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Repeat and Forever</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</link>
      <pubDate>Fri, 19 Jul 2024 14:46:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</guid>
      <description>SV Verification Directory
Repeat and Forever Loops The &amp;ldquo;repeat&amp;rdquo; and &amp;ldquo;forever&amp;rdquo; loops are another looping constructs available constructs in SystemVerilog, to execute a loop of code for a specific number of times or indefinitely. These loops are especially useful in testbenches and design verification when you need controlled or infinite iterations.
Repeat The repeat loop executes a block of code a specified number of times. This loop is handy when you know the exact number of iterations required.</description>
    </item>
    <item>
      <title>While and Do While Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</link>
      <pubDate>Fri, 19 Jul 2024 14:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</guid>
      <description>SV Verification Directory
While and Do While While and do while loops are used for iterative control structures that execute a block of code multiple times based on a condition. These loops are particularly useful when the number of iterations is not known beforehand and depends on the evaluation of the loop condition.
While Loop The &amp;ldquo;while&amp;rdquo; loop executes a block code until the specified condition is true. The condition is evaluated before each iteration.</description>
    </item>
    <item>
      <title>For and Foreach Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</link>
      <pubDate>Fri, 19 Jul 2024 12:40:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</guid>
      <description>SV Verification Directory
For and Foreach Loops Loops are essential constructs to repeat a block of code for a specified amount of time. SystemVerilog provides two constructs to itreate over a range of elements and they are &amp;ldquo;for&amp;rdquo; loop and &amp;ldquo;foreach&amp;rdquo; loop.
For Loop Similar to other programming languages, the &amp;ldquo;for&amp;rdquo; loop in SystemVerilog repeats a block of code for a specified number of times. Ideal for controlled, indexed iterations where the number of iterations is known beforehand.</description>
    </item>
    <item>
      <title>Mod-N Counter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_18_23_30_22_mod_n_counter/</link>
      <pubDate>Thu, 18 Jul 2024 23:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_18_23_30_22_mod_n_counter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Mod-N Counter: An Overview A modulo-N counter (Mod-N) is counter that counts from 0 to N-1 and then wraps back to 0. This type of counter is useful in [Frequency Divider], timers and state machines. The number of flop-flop required to calculate a mod-N counter is ceil(log2(N)). Forexample: for a mod 10 counter the number of flip-flop required is 4 (ceil(log2(10))).
Verilog Code: Mod-N Counter module mod_cntr #(parameter N = 4)(/*AUTOARG*/ // Outputs mod_cntr, // Inputs clk, rst ); // Outputs output [N-1:0] mod_cntr; // Inputs input	clk; input	rst; logic [$clog2(N)-1:0] cntr_reg, cntr_nxt; /*AUTOREG*/ /*AUTOWIRE*/ always_ff@(posedge clk) if(rst) cntr_reg &amp;lt;= 0; else cntr_reg &amp;lt;= cntr_nxt; always_comb cntr_nxt = (cntr_reg == N-1) ?</description>
    </item>
    <item>
      <title>Code Converter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_18_21_58_46_code_converter/</link>
      <pubDate>Thu, 18 Jul 2024 21:58:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_18_21_58_46_code_converter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Code Converter: Binary to/from Gray Code Code converters are digital circuits that convert data from one form of binary representation to another. The two most important code converts are binary to gray and gray to binary. This converters are crucial digital components in designing [Aysnchronous FIFO].
Binary Code Binary code is a data representation system using only two states, zero (0) and one (1).</description>
    </item>
    <item>
      <title>Credit-Based Flow Control</title>
      <link>https://24x7fpga.com/article/2024_07_17_09_17_26_credit_based_flow_control/</link>
      <pubDate>Wed, 17 Jul 2024 09:17:00 -0400</pubDate>
      <guid>https://24x7fpga.com/article/2024_07_17_09_17_26_credit_based_flow_control/</guid>
      <description>Flow control is a crucial synchronization technique for data transmission. It ensures the efficient flow of data between the transmitter and the receiver by maintaining a balance between the data production rate of the sender and the data consumption rate of the receiver. The data that is being transmitted is buffered to maintain the balance between the transmitter and the receiver. The control mechanism holds the intermediate data in the buffer until the receiver is ready to process the data.</description>
    </item>
    <item>
      <title>Up/Down Counter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_16_22_30_28_up_down_counter/</link>
      <pubDate>Tue, 16 Jul 2024 22:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_16_22_30_28_up_down_counter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Up/Down Counter: An Overview An up/down counter, also known as a bidirectional counter, is a sequential digital circuit that can increment(count up) of decrement(count down) its values. The control signal dictates the direction of the counter. These counters are widely used in digital design for counting purposes such as in frequency division, event counting, etc.
Applications Digital Clocks: To count seconds, minutes, and hours.</description>
    </item>
    <item>
      <title>Universal Shift Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_10_20_30_35_universal_shift_register/</link>
      <pubDate>Wed, 10 Jul 2024 20:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_10_20_30_35_universal_shift_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Universal Shift Register: An Overview A universal shift register is a digital component that performs more than one data operation. It combines the functionalities of several types of shift registers into one, allowing for greater flexibility in data handling.
Design: 4-bit Universal Shift Register The figure below shows a design of a 4-bit universal shift register. It is an extension of a Shift Register which includes a series of Multiplexer which acts as switch to change the functionality of the register.</description>
    </item>
    <item>
      <title>Research</title>
      <link>https://24x7fpga.com/research/2024_07_08_10_15_40_research/</link>
      <pubDate>Mon, 08 Jul 2024 10:15:00 -0400</pubDate>
      <guid>https://24x7fpga.com/research/2024_07_08_10_15_40_research/</guid>
      <description>[Dissertation] &amp;ndash; RFSoC
My doctroal research concentrates on designing a wideband digital receiver system to receive and process the data for accurate multiple signal detection. Fast Fourier transform (FFT) is a widely used digital signal processing technique to detect signals in a bandwidth. However, there are some limitations when using the FFT algorithm for signal detection
The number of fixed-length samples used by the FFT algorithm determines the frequency resolution. The number of samples from the input signal must be increased to increase the frequency resolution.</description>
    </item>
    <item>
      <title>Shift Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_19_54_50_shift_register/</link>
      <pubDate>Sat, 06 Jul 2024 19:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_19_54_50_shift_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Shift Register: An Overview A shift register is a set of sequential registers placed in series to transfer and store data. The figure below shows a 4-bit serial shift register.
The waveform below shows the data being shifted from flip-flop 1 to 4 on the rising edge of the clock.
Applications Shift registers are typically used to collect and transfer data for various applications.</description>
    </item>
    <item>
      <title>Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_19_23_36_register/</link>
      <pubDate>Sat, 06 Jul 2024 19:23:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_19_23_36_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Register: An Overview A register in digital design is fast storage sequenctial circuit that can hold data temporarily. A widely used register is D Flip-FLop. A D Flip-Flop is an edge-triggered circuit that combines a pair of latches to store on bit.
Advantages of Registers Registers provide fast access to data compared to main memory. Ideal for temporary storage during data processing. Desgin: D Flip-Flop A D Flip-Flop is a edge-trigger register, either postive edge-triggered, negative edge-triggered or dual edge-triggered.</description>
    </item>
    <item>
      <title>Adder-Subtractor</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_16_50_01_adder_subtractor/</link>
      <pubDate>Sat, 06 Jul 2024 16:50:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_16_50_01_adder_subtractor/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Adder-Subtractor: An Overview An adder-subtractor is a combinational digital circuit that can perform the operation of an adder and subtractor based on the control signal. It is an essential component in arithmetic logic units (ALUs) in microprocessors and digital signal processors.
Applications of Adder-Subtractor CPUs, microcontrollers, and digital signal processors implement adder subtractors for arithmetic operations. Computer graphics make use of adder-subtractors blocks for calculating coordinates and pixel values.</description>
    </item>
    <item>
      <title>Comparator</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_15_54_47_comparator/</link>
      <pubDate>Sat, 06 Jul 2024 15:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_15_54_47_comparator/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Comparator: An Overview A comparator is a fundamental building block in digital design that compares two binary numbers. Comparators can be categorized based on their use and functionality.
Equality Comparator: it compares the two binary numbers to up a true bit or high when all the binary bits are identical and false or low when the bits are not identical. Magnitude Comparator: has three functionality, to determine the relationship between the two binary numbers that are being compared.</description>
    </item>
    <item>
      <title>Dynamic Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:41:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</guid>
      <description>SV Verification Directory
Dynamic Cast Casting refers to conversion of a variable to one data type to another data type. SystemVerilog provides two types of casting,
Static Casting Dynamic Casting Dynamic Casting Dynamic casting in SystemVerilog allows you to safely convert a handle of one class type to another class type at runtime, ensuring the cast is valid and the object is of the target type. The dynamic cast, $cast, allows you to check for out-of-bounds values.</description>
    </item>
    <item>
      <title>Static Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:32:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</guid>
      <description>SV Verification Directory
Static Cast Casting refers to conversion of a variable to one data type to another data type. SystemVerilog provides two types of casting,
Static Casting Dynamic Casting Static Casting Static casting converts one data type to another compartible datatypes, as the name suggest, the conversion data type is fixed. The cast (&amp;rsquo;) operator should be placed before the data along with the intended data type.
Example module static_conv; int i = 75; real r = 13.</description>
    </item>
    <item>
      <title>Structures</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</link>
      <pubDate>Tue, 02 Jul 2024 16:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</guid>
      <description>SV Verification Directory
Structure One of the biggest limitations of Verilog is the lack of data structures. In SystemVerilog, you can create a structure using the struct statement. A structure is a collection of data that can be synthesized.
Example of struct:
struct {logic [7:0] data_a, data_b, data_c;} data_s; data_s in_data; NOTE: By default a structure is unpacked.
Typedef for Struct To create multiple structure variables it is necessary to use typedef data type.</description>
    </item>
    <item>
      <title>Enumeration</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</link>
      <pubDate>Tue, 02 Jul 2024 15:05:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</guid>
      <description>SV Verification Directory
Enumeration In Verilog, it is possible to declare user-defined types using a define macro, shown below:
`define TYPE1 8 `define TYPE2 32 This does not create a new type but just performance text substitution. In SystemVerilog, a new type can be created with the following code:
typedef logic [Size-1:0] VAR_T; VAR_T var1, var2; The typedef and parameter statements can be put in a package so they can be shared across the design and testbench.</description>
    </item>
    <item>
      <title>Array Methods</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</link>
      <pubDate>Tue, 02 Jul 2024 09:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</guid>
      <description>SV Verification Directory
Array Methods Array methods are generic manipulation methods that apply to the entire array rather than iterating to every element in the array.
Basic Array Operations Copy: an array can be copied completely to another array without using a loop statement. Compare: two arrays can be compared for equality and inequality. Keep in mind that two arrays that are being compared or copied must be of the same base type and size.</description>
    </item>
    <item>
      <title>Associative Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</link>
      <pubDate>Tue, 02 Jul 2024 00:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</guid>
      <description>SV Verification Directory
Associative Arrays Associative arrays in SystemVerilog allow you to index arrays with arbitrary data types. An associative array can be stored by the simulator as a tree or a hash table. An associative array is declared with a data type in square brackets. Only the elements that are explicitly assigned are stored, making it memory-efficient for sparse arrays.
Example of associative arrays in SV is shown below:</description>
    </item>
    <item>
      <title>Queues</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</link>
      <pubDate>Mon, 01 Jul 2024 23:35:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</guid>
      <description>SV Verification Directory
Queues Queue is a new data type introduced in SystemVerilog that combines the best of a linked list and an array.
Like a linked list, elements can be added and removed anywhere in the queue, without performance degradation when using a dynamic array that has to allocate a new array and copy the entire contents. Like an array, any element in the queue can be directly accessed with the help of the index, without the linked list&amp;rsquo;s overhead of stepping through the preceding element.</description>
    </item>
    <item>
      <title>Dynamic Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</link>
      <pubDate>Mon, 01 Jul 2024 15:56:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</guid>
      <description>SV Verification Directory
Dymanic Arrays Dynamic arrays are arrays that do not have their size set during the compile time. They can be allocated and resized during simulation based on the design requirement so that the simulation cosumes minimal amount of memory. A dynamic array can be declare with empty word subscripts &amp;ldquo;[ ]&amp;rdquo;. The array is initially empty and must be called with the &amp;ldquo;new[ ]&amp;rdquo; constuctor to allocate space, passing in the number of entries in the square brackets.</description>
    </item>
    <item>
      <title>Packed and Unpacked Array</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</link>
      <pubDate>Sat, 29 Jun 2024 23:39:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</guid>
      <description>SV Verification Directory
Packed and Unpacked Array Packed and unpacked arrays are differentiated based on the way the arrays are stored in the memory. Generally, simulators store each element on a 32-bit word boundary. In a packed array, the elements are stored in contiguous memory locations whereas in an unpacked array, the elements are not stored in contiguous memory locations.
Packed Array A packed array can be declared by declaring the dimension before the identifier name shown below:</description>
    </item>
    <item>
      <title>Fixed-Size Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</link>
      <pubDate>Sat, 29 Jun 2024 23:25:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</guid>
      <description>SV Verification Directory
Fixed-Size Arrays An array is a collection of elements stored sequentially. An array in Verilog should be declared with upper and lower bounds. The lower bound in most of the arrays is zero. Fixed-size arrays have constant size and do not change during run time. The array size is set at compile time.
Single Dimension Array There are two ways in SystemVerilog to declare single-dimension arrays which are shown below:</description>
    </item>
    <item>
      <title>Redo In Vim</title>
      <link>https://24x7fpga.com/vim_directory/2024_06_28_15_38_01_redo_in_vim/</link>
      <pubDate>Fri, 28 Jun 2024 15:38:00 -0400</pubDate>
      <guid>https://24x7fpga.com/vim_directory/2024_06_28_15_38_01_redo_in_vim/</guid>
      <description>Reference
Redo in Vim Come out of the insert mode by pressing &amp;ldquo;Esc&amp;rdquo; and press &amp;ldquo;ctrl+shift+r&amp;rdquo; to redo.</description>
    </item>
    <item>
      <title>Undo In Vim</title>
      <link>https://24x7fpga.com/vim_directory/2024_06_28_15_35_07_undo_in_vim/</link>
      <pubDate>Fri, 28 Jun 2024 15:35:00 -0400</pubDate>
      <guid>https://24x7fpga.com/vim_directory/2024_06_28_15_35_07_undo_in_vim/</guid>
      <description>Reference
Undo Come out from the insert mode by pressing &amp;ldquo;Esc&amp;rdquo; and press &amp;lsquo;u&amp;rsquo; to undo.</description>
    </item>
    <item>
      <title>Copy A Word In A Line</title>
      <link>https://24x7fpga.com/vim_directory/2024_06_28_15_15_48_copy_a_word_in_a_line/</link>
      <pubDate>Fri, 28 Jun 2024 15:15:00 -0400</pubDate>
      <guid>https://24x7fpga.com/vim_directory/2024_06_28_15_15_48_copy_a_word_in_a_line/</guid>
      <description>Reference
Copying a Word To copy a word in a line you must go into visual mode in vim. You press &amp;lsquo;v&amp;rsquo; to go into visual mode.
First go to a the word that you want to copy using &amp;lsquo;w&amp;rsquo;. More instructin can be found @ Move The Cursor by One Word. Press &amp;lsquo;v&amp;rsquo; to get into visual mode. Use &amp;lsquo;h, j, k, l&amp;rsquo; to selected the word or a sentence.</description>
    </item>
    <item>
      <title>Move The Cursor by One Word</title>
      <link>https://24x7fpga.com/vim_directory/2024_06_28_15_10_34_move_the_cursor_by_one_word/</link>
      <pubDate>Fri, 28 Jun 2024 15:10:00 -0400</pubDate>
      <guid>https://24x7fpga.com/vim_directory/2024_06_28_15_10_34_move_the_cursor_by_one_word/</guid>
      <description>Reference
Jump the cursor by One Word To move the cursor location to the next word in vim use lowercase &amp;lsquo;w&amp;rsquo;.
To the begining of the line using the line number eg. :57. Press &amp;lsquo;w&amp;rsquo; the cursor will move to the next word. </description>
    </item>
    <item>
      <title>Logic Type</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</link>
      <pubDate>Fri, 28 Jun 2024 14:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</guid>
      <description>SV Verification Directory
Logic Type Data Types SystemVerilog includes all the data types that are available with Verilog and add many new data types to help both hardware design engineers and verification engineers. Below is a table showing an extensive list of data types availabe in SystemVerilog.
Language Data Type State Type No. of Bits Signed/Unsigned C Equivalent SystemVerilog/Verilog Wire 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Reg 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Interger 4 32 Signed - SystemVerilog/Verilog Real 2 Double Precision Floating point Double SystemVerilog/Verilog Time 4 64 Unsigned - SystemVerilog Logic 4 &amp;gt;=1 unsigned - SystemVerilog Bit 2 &amp;gt;=1 unsigned - SystemVerilog Byte 2 8 Signed Char SystemVerilog Int 2 32 Signed Int SystemVerilog Shortint 2 16 Signed Short Int SystemVerilog Longint 2 64 Signed Long Int Note: signed variables can cause unexpected results with randomization.</description>
    </item>
    <item>
      <title>SV Verification Directory</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory/</link>
      <pubDate>Thu, 27 Jun 2024 16:53:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory/</guid>
      <description>In the rapidly evolving world of digital design, verification is paramount to ensuring that designs function correctly and efficiently. SystemVerilog, an extension of the Verilog hardware description language, has become a critical tool for verification engineers. This blog post aims to introduce SystemVerilog verification, highlighting its significance, features, and basic concepts to help you get started on your verification journey.
Layered Testbench Testbench overview Data Types Logic Type Fixed-Size Arrays Packed and Unpacked Array Dynamic Arrays Queues Associative Arrays Array Methods Enumeration Structures Streaming Operator Type Converstion Static Cast Dynamic Cast Flow Control For and Foreach Loops While and Do While Loops Repeat and Forever Break and Continue Tasks and Functions Tasks Functions Process Fork Join Fork Join Any Fork Join None Wait Fork Disable Fork OOP in SV Object-Oriented Programming Class Handle Object Method This Keyword Static Class Properties and Methods Shallow Copy and Deep Copy Four Pillars of OOP Inheritance Super Keyword Virtual Keyword Polymorphism Encapsulation Interprocess Communication Events Mailbox Semaphore Interface Interface Modport Clocking Block </description>
    </item>
    <item>
      <title>Decoder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_23_21_30_22_decoder/</link>
      <pubDate>Sun, 23 Jun 2024 21:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_23_21_30_22_decoder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Decoder: An Overview The functionality of a decoder is the opposite of an Encoder. A decoder is a combinational circuit that converts a binary coder to a set of output signals with only one bit of the being high at any given time. It consists of N input lines and 2^N output lines.
Design: 2-to-4 Decoder A 2-to-4 decoder consists of two input lines and four output lines.</description>
    </item>
    <item>
      <title>Encoder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_23_20_40_25_encoder/</link>
      <pubDate>Sun, 23 Jun 2024 20:40:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_23_20_40_25_encoder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Encoder: An Overview An encoder is a digital combinational circuit that converts 2^n inputs to n outputs. It converts a set of binary inputs to binary-coded output, where only one input line is active at a given time.
Design: 4-to-2 Encoder A 4-to-2 encoder, where n = 2 i.e., it consists of 2^n = 2^2 = 4 input lines named as in[3], in[2], in[1], in[0] and two output lines named as out[1] and out[0].</description>
    </item>
    <item>
      <title>A Case Study on Effective Pipeline Design in Digital Systems</title>
      <link>https://24x7fpga.com/article/2024_06_18_16_45_29_a_case_study_on_effective_pipeline_design_in_digital_systems/</link>
      <pubDate>Tue, 18 Jun 2024 16:45:00 -0400</pubDate>
      <guid>https://24x7fpga.com/article/2024_06_18_16_45_29_a_case_study_on_effective_pipeline_design_in_digital_systems/</guid>
      <description>Published Article
Throughput and latency are fundamental concepts in moderm digital system. Throughput refers to the time the system takes to process the data per clock cycle where latency refers to the time it takes for the data to travese from one location to another to complete an operation. High throughput and low latency are essentail for today&amp;rsquo;s fast-paced digital world. For example, higher throughput ensure smooth and uninterrupted audio and video streaming and low latency provides seamless and responsive gaming experience reducing lag.</description>
    </item>
    <item>
      <title>De-Multiplexer</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_14_22_07_44_de_multiplexer/</link>
      <pubDate>Fri, 14 Jun 2024 22:07:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_14_22_07_44_de_multiplexer/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
De-Multiplexer (DEMUX): An Overview A DEMUX or data distributor is a one-to-many combinational circuit that receives inputs from a single input line and transmits the same information over one of &amp;rsquo;n&amp;rsquo; possible output lines. DEMUX transmits the same data that is received on the input to different destinations. A de-multiplexer is a 1-to-N device, where N/n is the number of outputs and with &amp;rsquo;m&amp;rsquo; select line, therefore, 2^m = n.</description>
    </item>
    <item>
      <title>Multiplexer</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_13_12_22_45_multiplexer/</link>
      <pubDate>Thu, 13 Jun 2024 12:22:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_13_12_22_45_multiplexer/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Multiplexer (MUX): An Overview A multiplexer is a digital circuit that selects one input out of many inputs, hence, it is also called a data selector. It consists of 2^n inputs with n selector lines, which are used to select which input to send to the output.
Need For Multiplexers The need for MUXs arises wherever there is a need to transmit multiple data over a shared communication channel.</description>
    </item>
    <item>
      <title>Full Adder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_08_11_32_42_full_adder/</link>
      <pubDate>Sat, 08 Jun 2024 11:32:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_08_11_32_42_full_adder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Full Adder A full adder is a basic building block of a digital circuit. Full adder requires three inputs a, b, and c(carry-in) to result in two outputs s(sum) and co(carry-out).
Full adder truth table:
A B C SUM (S) Carry (Co) 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 Boolean equation for sum and carry is :</description>
    </item>
    <item>
      <title>Half Adder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_05_22_56_41_half_adder/</link>
      <pubDate>Wed, 05 Jun 2024 22:56:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_05_22_56_41_half_adder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Half Adder Half adder is a combinational arithmetic circuit. Its functionality is to add two 1-bit binary digits to produce a sum bit and carry as the output.
Half adder truth table:
A B Sum (S) Carry (Co) 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Boolean equation for sum and carry can be written as :</description>
    </item>
    <item>
      <title>RTL Design Directory</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/</link>
      <pubDate>Wed, 05 Jun 2024 00:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/</guid>
      <description>Welcome to my comprehensive collection of RTL(Register Transfer Level) designs. It is an evolving collection highlighting my projects, skills, and achievements in digital circuit design and verification. I specialize in developing efficient, high-performance hardware architectures using industry-standard languages like SystemVerilog and Verilog. Explore my blog for insightful articles on the latest trends and best practices in RTL design, and visit the tutorials section for step-by-step guides to mastering this critical aspect of hardware engineering.</description>
    </item>
    <item>
      <title>Emacs Display Image</title>
      <link>https://24x7fpga.com/emacs_directory/2024_05_31_12_47_08_emacs_display_image/</link>
      <pubDate>Fri, 31 May 2024 12:47:00 -0400</pubDate>
      <guid>https://24x7fpga.com/emacs_directory/2024_05_31_12_47_08_emacs_display_image/</guid>
      <description>Reference1, Reference2
How to include an image in emacs? Simple way to include images in an org document is by using the following command:
[[ ./path/to/image.png ]] How to display the image in emacs? To display an inline image in emacs org file simply type &amp;quot; C-c C-x C-v&amp;quot;. The same command is used to toggle the display.
How to add caption and label to the image? To include the caption and label to the name it is necessary to have the image link in the separate line and add &amp;quot; #+caption and #+name: &amp;quot; before the link.</description>
    </item>
    <item>
      <title>Vim Find and Replace</title>
      <link>https://24x7fpga.com/vim_directory/2024_05_30_20_45_11-vim_find_and_replace/</link>
      <pubDate>Thu, 30 May 2024 20:45:00 -0400</pubDate>
      <guid>https://24x7fpga.com/vim_directory/2024_05_30_20_45_11-vim_find_and_replace/</guid>
      <description>Reference
Find and Replace Command The command to find and replace a word in a document is by the use of :subtitute (:S) command. The basic command is as follows:
:[range]s/{pattern}/{string}/[flags] [count] [range] = the word to be replaced will be searched within this specified lines. {pattern} = the word that has to be replaced {string} = the new replaced word [flags] = is constraint for the command [count] = is a postive number that mutliplies the command Note: To replace a special charater use &amp;ldquo;\&amp;rdquo; before the character, for example, to replace $apple =&amp;gt; ^orange use &amp;quot;</description>
    </item>
    <item>
      <title></title>
      <link>https://24x7fpga.com/about/about/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://24x7fpga.com/about/about/</guid>
      <description>Hi there ðŸ‘‹. I&amp;rsquo;m Kiran. I work as Graduate Research Assistant at Wright State University currently pursuing my Doctoral degree.
My background includes Digital Design, RTL design, FPGA prototyping, Circuit design, and I have worked as a graduate teaching assistant while pursuing a Masterâ€™s Degree in Electrical Engineering.
As a teaching assistant I Instructed students in modeling digital systems using hardware descriptive language. Implemented and tested the designs on FPGAs. Evaluated the student&amp;rsquo;s performance based on quizzes and graded them accordingly for Digital Integrated Circuit Design Lab.</description>
    </item>
  </channel>
</rss>