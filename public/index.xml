<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Home</title>
    <link>https://24x7fpga.com/</link>
    <description>Recent content on Home</description>
    <generator>Hugo -- 0.121.1</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Jul 2024 15:18:00 -0400</lastBuildDate>
    <atom:link href="https://24x7fpga.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Break and Continue</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</link>
      <pubDate>Fri, 19 Jul 2024 15:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_15_18_41_break_and_continue/</guid>
      <description>SV Verification Directory
Break and Continue Break and continue in SytemVerilog is used to control the loops. When a &amp;ldquo;break&amp;rdquo; statement is encounted, the loop is terminated and control moves to outside of the loop. Whereas, when a &amp;ldquo;continue&amp;rdquo; statement is encounted, the consecutive blocks of code is skipped and the control is moved to the next loop iteration value.
Example Code: Break and Continue module break_and_continue; initial begin int i = 0; $display(&amp;#34;---------- Even Number ----------&amp;#34;); forever begin if(i % 2 == 0) begin $display(&amp;#34;%0d is an Even Number&amp;#34;, i); i = i + 1; continue; end else begin if(i &amp;gt; 20) break; end i = i + 1; #1; end end endmodule Execute the code in EDA Playground</description>
    </item>
    <item>
      <title>Repeat and Forever</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</link>
      <pubDate>Fri, 19 Jul 2024 14:46:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_46_31_repeat_and_forever/</guid>
      <description>SV Verification Directory
Repeat and Forever Loops The &amp;ldquo;repeat&amp;rdquo; and &amp;ldquo;forever&amp;rdquo; loops are another looping constructs available constructs in SystemVerilog, to execute a loop of code for a specific number of times or indefinitely. These loops are especially useful in testbenches and design verification when you need controlled or infinite iterations.
Repeat The repeat loop executes a block of code a specified number of times. This loop is handy when you know the exact number of iterations required.</description>
    </item>
    <item>
      <title>While and Do While Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</link>
      <pubDate>Fri, 19 Jul 2024 14:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_14_21_47_while_and_do_while_loops/</guid>
      <description>SV Verification Directory
While and Do While While and do while loops are used for iterative control structures that execute a block of code multiple times based on a condition. These loops are particularly useful when the number of iterations is not known beforehand and depends on the evaluation of the loop condition.
While Loop The &amp;ldquo;while&amp;rdquo; loop executes a block code until the specified condition is true. The condition is evaluated before each iteration.</description>
    </item>
    <item>
      <title>For and Foreach Loops</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</link>
      <pubDate>Fri, 19 Jul 2024 12:40:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_19_12_40_49_for_and_foreach_loops/</guid>
      <description>SV Verification Directory
For and Foreach Loops Loops are essential constructs to repeat a block of code for a specified amount of time. SystemVerilog provides two constructs to itreate over a range of elements and they are &amp;ldquo;for&amp;rdquo; loop and &amp;ldquo;foreach&amp;rdquo; loop.
For Loop Similar to other programming languages, the &amp;ldquo;for&amp;rdquo; loop in SystemVerilog repeats a block of code for a specified number of times. Ideal for controlled, indexed iterations where the number of iterations is known beforehand.</description>
    </item>
    <item>
      <title>Mod-N Counter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_18_23_30_22_mod_n_counter/</link>
      <pubDate>Thu, 18 Jul 2024 23:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_18_23_30_22_mod_n_counter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Mod-N Counter: An Overview A modulo-N counter (Mod-N) is counter that counts from 0 to N-1 and then wraps back to 0. This type of counter is useful in [Frequency Divider], timers and state machines. The number of flop-flop required to calculate a mod-N counter is ceil(log2(N)). Forexample: for a mod 10 counter the number of flip-flop required is 4 (ceil(log2(10))).
Verilog Code: Mod-N Counter module mod_cntr #(parameter N = 4)(/*AUTOARG*/ // Outputs mod_cntr, // Inputs clk, rst ); // Outputs output [N-1:0] mod_cntr; // Inputs input	clk; input	rst; logic [$clog2(N)-1:0] cntr_reg, cntr_nxt; /*AUTOREG*/ /*AUTOWIRE*/ always_ff@(posedge clk) if(rst) cntr_reg &amp;lt;= 0; else cntr_reg &amp;lt;= cntr_nxt; always_comb cntr_nxt = (cntr_reg == N-1) ?</description>
    </item>
    <item>
      <title>Code Converter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_18_21_58_46_code_converter/</link>
      <pubDate>Thu, 18 Jul 2024 21:58:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_18_21_58_46_code_converter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Code Converter: Binary to/from Gray Code Code converters are digital circuits that convert data from one form of binary representation to another. The two most important code converts are binary to gray and gray to binary. This converters are crucial digital components in designing [Aysnchronous FIFO].
Binary Code Binary code is a data representation system using only two states, zero (0) and one (1).</description>
    </item>
    <item>
      <title>Credit-Based Flow Control</title>
      <link>https://24x7fpga.com/article/2024_07_17_09_17_26_credit_based_flow_control/</link>
      <pubDate>Wed, 17 Jul 2024 09:17:00 -0400</pubDate>
      <guid>https://24x7fpga.com/article/2024_07_17_09_17_26_credit_based_flow_control/</guid>
      <description>Flow control is a crucial synchronization technique for data transmission. It ensures the efficient flow of data between the transmitter and the receiver by maintaining a balance between the data production rate of the sender and the data consumption rate of the receiver. The data that is being transmitted is buffered to maintain the balance between the transmitter and the receiver. The control mechanism holds the intermediate data in the buffer until the receiver is ready to process the data.</description>
    </item>
    <item>
      <title>Up/Down Counter</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_16_22_30_28_up_down_counter/</link>
      <pubDate>Tue, 16 Jul 2024 22:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_16_22_30_28_up_down_counter/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Up/Down Counter: An Overview An up/down counter, also known as a bidirectional counter, is a sequential digital circuit that can increment(count up) of decrement(count down) its values. The control signal dictates the direction of the counter. These counters are widely used in digital design for counting purposes such as in frequency division, event counting, etc.
Applications Digital Clocks: To count seconds, minutes, and hours.</description>
    </item>
    <item>
      <title>Universal Shift Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_10_20_30_35_universal_shift_register/</link>
      <pubDate>Wed, 10 Jul 2024 20:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_10_20_30_35_universal_shift_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Universal Shift Register: An Overview A universal shift register is a digital component that performs more than one data operation. It combines the functionalities of several types of shift registers into one, allowing for greater flexibility in data handling.
Design: 4-bit Universal Shift Register The figure below shows a design of a 4-bit universal shift register. It is an extension of a Shift Register which includes a series of Multiplexer which acts as switch to change the functionality of the register.</description>
    </item>
    <item>
      <title>Research</title>
      <link>https://24x7fpga.com/research/2024_07_08_10_15_40_research/</link>
      <pubDate>Mon, 08 Jul 2024 10:15:00 -0400</pubDate>
      <guid>https://24x7fpga.com/research/2024_07_08_10_15_40_research/</guid>
      <description>[Dissertation] &amp;ndash; [RFSoC]
My doctroal research concentrates on designing a wideband digital receiver system to receive and process the data for accurate multiple signal detection. Fast Fourier transform (FFT) is a widely used digital signal processing technique to detect signals in a bandwidth. However, there are some limitations when using the FFT algorithm for signal detection
The number of fixed-length samples used by the FFT algorithm determines the frequency resolution. The number of samples from the input signal must be increased to increase the frequency resolution.</description>
    </item>
    <item>
      <title>Shift Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_19_54_50_shift_register/</link>
      <pubDate>Sat, 06 Jul 2024 19:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_19_54_50_shift_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Shift Register: An Overview A shift register is a set of sequential registers placed in series to transfer and store data. The figure below shows a 4-bit serial shift register.
The waveform below shows the data being shifted from flip-flop 1 to 4 on the rising edge of the clock.
Applications Shift registers are typically used to collect and transfer data for various applications.</description>
    </item>
    <item>
      <title>Register</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_19_23_36_register/</link>
      <pubDate>Sat, 06 Jul 2024 19:23:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_19_23_36_register/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Register: An Overview A register in digital design is fast storage sequenctial circuit that can hold data temporarily. A widely used register is D Flip-FLop. A D Flip-Flop is an edge-triggered circuit that combines a pair of latches to store on bit.
Advantages of Registers Registers provide fast access to data compared to main memory. Ideal for temporary storage during data processing. Desgin: D Flip-Flop A D Flip-Flop is a edge-trigger register, either postive edge-triggered, negative edge-triggered or dual edge-triggered.</description>
    </item>
    <item>
      <title>Adder-Subtractor</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_16_50_01_adder_subtractor/</link>
      <pubDate>Sat, 06 Jul 2024 16:50:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_16_50_01_adder_subtractor/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Adder-Subtractor: An Overview An adder-subtractor is a combinational digital circuit that can perform the operation of an adder and subtractor based on the control signal. It is an essential component in arithmetic logic units (ALUs) in microprocessors and digital signal processors.
Applications of Adder-Subtractor CPUs, microcontrollers, and digital signal processors implement adder subtractors for arithmetic operations. Computer graphics make use of adder-subtractors blocks for calculating coordinates and pixel values.</description>
    </item>
    <item>
      <title>Comparator</title>
      <link>https://24x7fpga.com/rtl_directory/2024_07_06_15_54_47_comparator/</link>
      <pubDate>Sat, 06 Jul 2024 15:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_07_06_15_54_47_comparator/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Comparator: An Overview A comparator is a fundamental building block in digital design that compares two binary numbers. Comparators can be categorized based on their use and functionality.
Equality Comparator: it compares the two binary numbers to up a true bit or high when all the binary bits are identical and false or low when the bits are not identical. Magnitude Comparator: has three functionality, to determine the relationship between the two binary numbers that are being compared.</description>
    </item>
    <item>
      <title>Dynamic Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:41:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_41_56_dynamic_cast/</guid>
      <description>SV Verification Directory
Dynamic Cast The dynamic cast, $cast, allows you to check for out-of-bounds values. Use dynamic cast when converting from a type with a large number of values than the destination, such as int to en enumerated variables.</description>
    </item>
    <item>
      <title>Static Cast</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</link>
      <pubDate>Tue, 02 Jul 2024 18:32:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_18_32_19_static_cast/</guid>
      <description>SV Verification Directory
Static Cast The static cast operation converts between two types with no checking of values. Specify the destination type, an apostrophe, and the expression to be converted as shown below:
int i; real r; i = int &amp;#39;(75.0); r = real &amp;#39;(75); </description>
    </item>
    <item>
      <title>Structures</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</link>
      <pubDate>Tue, 02 Jul 2024 16:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_16_54_49_structures/</guid>
      <description>SV Verification Directory
Structure One of the biggest limitations of Verilog is the lack of data structures. In SystemVerilog, you can create a structure using the struct statement. A structure is a collection of data that can be synthesized.
Example of struct:
struct {logic [7:0] data_a, data_b, data_c;} data_s; data_s in_data; NOTE: By default a structure is unpacked.
Typedef for Struct To create multiple structure variables it is necessary to use typedef data type.</description>
    </item>
    <item>
      <title>Enumeration</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</link>
      <pubDate>Tue, 02 Jul 2024 15:05:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_15_05_30_enumeration/</guid>
      <description>SV Verification Directory
Enumeration In Verilog, it is possible to declare user-defined types using a define macro, shown below:
`define TYPE1 8 `define TYPE2 32 This does not create a new type but just performance text substitution. In SystemVerilog, a new type can be created with the following code:
typedef logic [Size-1:0] VAR_T; VAR_T var1, var2; The typedef and parameter statements can be put in a package so they can be shared across the design and testbench.</description>
    </item>
    <item>
      <title>Array Methods</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</link>
      <pubDate>Tue, 02 Jul 2024 09:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_09_48_08_array_methods/</guid>
      <description>SV Verification Directory
Array Methods Array methods are generic manipulation methods that apply to the entire array rather than iterating to every element in the array.
Basic Array Operations Copy: an array can be copied completely to another array without using a loop statement. Compare: two arrays can be compared for equality and inequality. Keep in mind that two arrays that are being compared or copied must be of the same base type and size.</description>
    </item>
    <item>
      <title>Associative Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</link>
      <pubDate>Tue, 02 Jul 2024 00:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_02_00_18_56_associative_arrays/</guid>
      <description>SV Verification Directory
Associative Arrays Associative arrays in SystemVerilog allow you to index arrays with arbitrary data types. An associative array can be stored by the simulator as a tree or a hash table. An associative array is declared with a data type in square brackets. Only the elements that are explicitly assigned are stored, making it memory-efficient for sparse arrays.
Example of associative arrays in SV is shown below:</description>
    </item>
    <item>
      <title>Queues</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</link>
      <pubDate>Mon, 01 Jul 2024 23:35:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_23_35_47_queues/</guid>
      <description>SV Verification Directory
Queues Queue is a new data type introduced in SystemVerilog that combines the best of a linked list and an array.
Like a linked list, elements can be added and removed anywhere in the queue, without performance degradation when using a dynamic array that has to allocate a new array and copy the entire contents. Like an array, any element in the queue can be directly accessed with the help of the index, without the linked list&amp;rsquo;s overhead of stepping through the preceding element.</description>
    </item>
    <item>
      <title>Dynamic Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</link>
      <pubDate>Mon, 01 Jul 2024 15:56:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_07_01_15_56_35_dynamic_arrays/</guid>
      <description>SV Verification Directory
Dymanic Arrays Dynamic arrays are arrays that do not have their size set during the compile time. They can be allocated and resized during simulation based on the design requirement so that the simulation cosumes minimal amount of memory. A dynamic array can be declare with empty word subscripts &amp;ldquo;[ ]&amp;rdquo;. The array is initially empty and must be called with the &amp;ldquo;new[ ]&amp;rdquo; constuctor to allocate space, passing in the number of entries in the square brackets.</description>
    </item>
    <item>
      <title>Packed and Unpacked Array</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</link>
      <pubDate>Sat, 29 Jun 2024 23:39:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_39_49_packed_and_unpacked_array/</guid>
      <description>SV Verification Directory
Packed and Unpacked Array Packed and unpacked arrays are differentiated based on the way the arrays are stored in the memory. Generally, simulators store each element on a 32-bit word boundary. In a packed array, the elements are stored in contiguous memory locations whereas in an unpacked array, the elements are not stored in contiguous memory locations.
Packed Array A packed array can be declared by declaring the dimension before the identifier name shown below:</description>
    </item>
    <item>
      <title>Fixed-Size Arrays</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</link>
      <pubDate>Sat, 29 Jun 2024 23:25:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_29_23_25_03_fixed_size_arrays/</guid>
      <description>SV Verification Directory
Fixed-Size Arrays An array is a collection of elements stored sequentially. An array in Verilog should be declared with upper and lower bounds. The lower bound in most of the arrays is zero. Fixed-size arrays have constant size and do not change during run time. The array size is set at compile time.
Single Dimension Array There are two ways in SystemVerilog to declare single-dimension arrays which are shown below:</description>
    </item>
    <item>
      <title>Logic Type</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</link>
      <pubDate>Fri, 28 Jun 2024 14:48:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_28_14_48_33_logic_type/</guid>
      <description>SV Verification Directory
Logic Type Data Types SystemVerilog includes all the data types that are available with Verilog and add many new data types to help both hardware design engineers and verification engineers. Below is a table showing an extensive list of data types availabe in SystemVerilog.
Language Data Type State Type No. of Bits Signed/Unsigned C Equivalent SystemVerilog/Verilog Wire 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Reg 4 &amp;gt;=1 Unsigned - SystemVerilog/Verilog Interger 4 32 Signed - SystemVerilog/Verilog Real 2 Double Precision Floating point Double SystemVerilog/Verilog Time 4 64 Unsigned - SystemVerilog Logic 4 &amp;gt;=1 unsigned - SystemVerilog Bit 2 &amp;gt;=1 unsigned - SystemVerilog Byte 2 8 Signed Char SystemVerilog Int 2 32 Signed Int SystemVerilog Shortint 2 16 Signed Short Int SystemVerilog Longint 2 64 Signed Long Int Note: signed variables can cause unexpected results with randomization.</description>
    </item>
    <item>
      <title>SV Verification Directory</title>
      <link>https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory/</link>
      <pubDate>Thu, 27 Jun 2024 16:53:00 -0400</pubDate>
      <guid>https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory/</guid>
      <description>In the rapidly evolving world of digital design, verification is paramount to ensuring that designs function correctly and efficiently. SystemVerilog, an extension of the Verilog hardware description language, has become a critical tool for verification engineers. This blog post aims to introduce SystemVerilog verification, highlighting its significance, features, and basic concepts to help you get started on your verification journey.
Layered Testbench Testbench overview Data Types Logic Type Fixed-Size Arrays Packed and Unpacked Array Dynamic Arrays Queues Associative Arrays Array Methods Enumeration Structures Streaming Operator Type Converstion Static Cast Dynamic Cast Flow Control For and Foreach Loops While and Do While Loops Repeat and Forever Break and Continue Tasks and Functions Tasks Functions Process Fork_Join Fork_Join_Any Fork_Join_None Wait_Fork Disable_Fork Classes Terminology Interprocess Communication Mailbox Semaphore Events Randomization </description>
    </item>
    <item>
      <title>Decoder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_23_21_30_22_decoder/</link>
      <pubDate>Sun, 23 Jun 2024 21:30:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_23_21_30_22_decoder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Decoder: An Overview The functionality of a decoder is the opposite of an Encoder. A decoder is a combinational circuit that converts a binary coder to a set of output signals with only one bit of the being high at any given time. It consists of N input lines and 2^N output lines.
Design: 2-to-4 Decoder A 2-to-4 decoder consists of two input lines and four output lines.</description>
    </item>
    <item>
      <title>Encoder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_23_20_40_25_encoder/</link>
      <pubDate>Sun, 23 Jun 2024 20:40:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_23_20_40_25_encoder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Encoder: An Overview An encoder is a digital combinational circuit that converts 2^n inputs to n outputs. It converts a set of binary inputs to binary-coded output, where only one input line is active at a given time.
Design: 4-to-2 Encoder A 4-to-2 encoder, where n = 2 i.e., it consists of 2^n = 2^2 = 4 input lines named as in[3], in[2], in[1], in[0] and two output lines named as out[1] and out[0].</description>
    </item>
    <item>
      <title>A Case Study on Effective Pipeline Design in Digital Systems</title>
      <link>https://24x7fpga.com/article/2024_06_18_16_45_29_a_case_study_on_effective_pipeline_design_in_digital_systems/</link>
      <pubDate>Tue, 18 Jun 2024 16:45:00 -0400</pubDate>
      <guid>https://24x7fpga.com/article/2024_06_18_16_45_29_a_case_study_on_effective_pipeline_design_in_digital_systems/</guid>
      <description>Published Article
Throughput and latency are fundamental concepts in moderm digital system. Throughput refers to the time the system takes to process the data per clock cycle where latency refers to the time it takes for the data to travese from one location to another to complete an operation. High throughput and low latency are essentail for today&amp;rsquo;s fast-paced digital world. For example, higher throughput ensure smooth and uninterrupted audio and video streaming and low latency provides seamless and responsive gaming experience reducing lag.</description>
    </item>
    <item>
      <title>De-Multiplexer</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_14_22_07_44_de_multiplexer/</link>
      <pubDate>Fri, 14 Jun 2024 22:07:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_14_22_07_44_de_multiplexer/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
De-Multiplexer (DEMUX): An Overview A DEMUX or data distributor is a one-to-many combinational circuit that receives inputs from a single input line and transmits the same information over one of &amp;rsquo;n&amp;rsquo; possible output lines. DEMUX transmits the same data that is received on the input to different destinations. A de-multiplexer is a 1-to-N device, where N/n is the number of outputs and with &amp;rsquo;m&amp;rsquo; select line, therefore, 2^m = n.</description>
    </item>
    <item>
      <title>Multiplexer</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_13_12_22_45_multiplexer/</link>
      <pubDate>Thu, 13 Jun 2024 12:22:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_13_12_22_45_multiplexer/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Multiplexer (MUX): An Overview A multiplexer is a digital circuit that selects one input out of many inputs, hence, it is also called a data selector. It consists of 2^n inputs with n selector lines, which are used to select which input to send to the output.
Need For Multiplexers The need for MUXs arises wherever there is a need to transmit multiple data over a shared communication channel.</description>
    </item>
    <item>
      <title>Full Adder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_08_11_32_42_full_adder/</link>
      <pubDate>Sat, 08 Jun 2024 11:32:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_08_11_32_42_full_adder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Full Adder A full adder is a basic building block of a digital circuit. Full adder requires three inputs a, b, and c(carry-in) to result in two outputs s(sum) and co(carry-out).
Full adder truth table:
A B C SUM (S) Carry (Co) 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 Boolean equation for sum and carry is :</description>
    </item>
    <item>
      <title>Half Adder</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_05_22_56_41_half_adder/</link>
      <pubDate>Wed, 05 Jun 2024 22:56:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_05_22_56_41_half_adder/</guid>
      <description>Design &amp;ndash; Testbench &amp;ndash; RTL Design Directory
Half Adder Half adder is a combinational arithmetic circuit. Its functionality is to add two 1-bit binary digits to produce a sum bit and carry as the output.
Half adder truth table:
A B Sum (S) Carry (Co) 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Boolean equation for sum and carry can be written as :</description>
    </item>
    <item>
      <title>RTL Design Directory</title>
      <link>https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/</link>
      <pubDate>Wed, 05 Jun 2024 00:21:00 -0400</pubDate>
      <guid>https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/</guid>
      <description>Welcome to my comprehensive collection of RTL(Register Transfer Level) designs. It is an evolving collection highlighting my projects, skills, and achievements in digital circuit design and verification. I specialize in developing efficient, high-performance hardware architectures using industry-standard languages like SystemVerilog and Verilog. Explore my blog for insightful articles on the latest trends and best practices in RTL design, and visit the tutorials section for step-by-step guides to mastering this critical aspect of hardware engineering.</description>
    </item>
    <item>
      <title></title>
      <link>https://24x7fpga.com/about/about/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://24x7fpga.com/about/about/</guid>
      <description>Hi there 👋. I&amp;rsquo;m Kiran. I work as Graduate Research Assistant at Wright State University currently pursuing my Doctoral degree.
My background includes Digital Design, RTL design, FPGA prototyping, Circuit design, and I have worked as a graduate teaching assistant while pursuing a Master’s Degree in Electrical Engineering.
As a teaching assistant I Instructed students in modeling digital systems using hardware descriptive language. Implemented and tested the designs on FPGAs. Evaluated the student&amp;rsquo;s performance based on quizzes and graded them accordingly for Digital Integrated Circuit Design Lab.</description>
    </item>
  </channel>
</rss>