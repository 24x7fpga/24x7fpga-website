<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Uvm_directories on Home</title>
    <link>https://24x7fpga.com/uvm_directory/</link>
    <description>Recent content in Uvm_directories on Home</description>
    <generator>Hugo -- 0.121.1</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Oct 2024 11:18:00 -0400</lastBuildDate>
    <atom:link href="https://24x7fpga.com/uvm_directory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UVM Resource and Configuration Database</title>
      <link>https://24x7fpga.com/uvm_directory/2024_10_06_11_18_25_uvm_resource_and_configuration_database/</link>
      <pubDate>Sun, 06 Oct 2024 11:18:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_10_06_11_18_25_uvm_resource_and_configuration_database/</guid>
      <description>Source &amp;ndash; UVM Framework Directory
Data can be shared across the an UVM testbench using two key mechanisms: the configuration database and the resources database. While both serve the purpose of sharing data between components, they are used in distinct contexts. The configuration database is typically used for setting up component-specific configurations, while the resources database is a more general-purpose tool for sharing any kind of data across the testbench.</description>
    </item>
    <item>
      <title>UVM Phases</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/</link>
      <pubDate>Thu, 26 Sep 2024 13:20:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/</guid>
      <description>UVM Framework Directory
In UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.
Figure 1: UVM Phases
The phases can be caterogised as time consumed phases and non-time consumed phase.</description>
    </item>
    <item>
      <title>UVM Common Operations</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_25_14_36_39_uvm_common_operations/</link>
      <pubDate>Wed, 25 Sep 2024 14:36:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_25_14_36_39_uvm_common_operations/</guid>
      <description>Source &amp;ndash; UVM Framework Directory
The uvm_object provides a set of predefined methods for common operations.
UVM Method Virtual Method Description copy do_copy Performs a deep copy of an object clone do_copy creates a new object and performs a deep copy of the object compare do_compare Compares one object to another of the same dat type print do_print Prints the result of convert2string to the terminal sprint do_print Returns the result fo the convert2string convert2string - Returns a string representation of the object copy This makes deep copy of a specified object.</description>
    </item>
    <item>
      <title>UVM Report Object</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_23_11_00_17_uvm_report_object/</link>
      <pubDate>Mon, 23 Sep 2024 11:00:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_23_11_00_17_uvm_report_object/</guid>
      <description>Source &amp;ndash; UVM Framework Directory
The uvm_report_object provides an interface to the UVM reporting facility. UVM reporting plays a crucial role in tracking the progress of the testbench, identifying issues, and debugging. It provies a rich set fo message display commands and methods to track and report erros, warnings and information.
Figure 1: UVM Reporting Classes
The methods in uvm_report_object are delegated to the uvm_report_handler, which manages reporting configurations such as actions, verbosity, and other settings.</description>
    </item>
    <item>
      <title>UVM Base Class Library</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_22_09_38_07_uvm_base_class_library/</link>
      <pubDate>Sun, 22 Sep 2024 09:38:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_22_09_38_07_uvm_base_class_library/</guid>
      <description>UVM Framework Directory
The base class library in UVM serve as the building blocks for any testbench and verification environment. These classes provide reusable, modular components that help create a structured and scalable framework, ensuring efficiency and consistency across various test environments.
Figure 1: UVM Base Class
The UVM class library offers a wide range of built-in features for verification, including printing, copying, test phases, and more. Each component in the testbench architecture can be derived from the corresponding UVM class, which enhances readability and reduces development time, making the verification process more efficient and streamlined.</description>
    </item>
    <item>
      <title>UVM Testbench Overview</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_22_08_54_25_uvm_testbench_overview/</link>
      <pubDate>Sun, 22 Sep 2024 08:54:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_22_08_54_25_uvm_testbench_overview/</guid>
      <description>UVM Framework Directory
The UVM testbench follows a layered architecture, where each component is dedicated to a specific task and interacts with the rest of the testbench through well-defined interfaces. This design promotes modularity and reusability, making it easier to manage and extend the testbench. Figure 1 illustrates a typical UVM testbench architecture.
Figure 1: UVM Testbench Architecture
UVM Testbench The UVM Testbench is the top-level module in the hierarchy, where both the UVM Test and the Design Under Test (DUT) are instantiated.</description>
    </item>
    <item>
      <title>UVM Workflow in Vivado</title>
      <link>https://24x7fpga.com/uvm_directory/2024_09_04_14_44_52_uvm_workflow_in_vivado/</link>
      <pubDate>Wed, 04 Sep 2024 14:44:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_09_04_14_44_52_uvm_workflow_in_vivado/</guid>
      <description>UVM &amp;ndash; UVM Vivado Script &amp;ndash; UVM Python Script
The UVM (Universal Verification Methodology) workflow is centered around creating a testbench that integrates key UVM components such as drivers, monitors, and scoreboards, alongside the essential UVM library setup. Numerous commercial tools are available for simulating and verifying digital designs, including ModelSim, Cadence Xcelium, Synopsys VCS, Aldec Riviera-PRO, and Vivado Simulator. Another excellent option for experimenting with small-to-medium-sized verification projects is EDA Playground.</description>
    </item>
    <item>
      <title>UVM Framework Directory</title>
      <link>https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory/</link>
      <pubDate>Wed, 28 Aug 2024 12:39:00 -0400</pubDate>
      <guid>https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory/</guid>
      <description>UVM stands for Universal Verification Method developed by UVM Working Group that provides a standardized methodology for verifying digital integrated circuits. UVM is built on top of SystemVerilog and provides a useful framework for creating reusable and scalable testbenchs. The framework provides a set of building blocks or pre-built design kits that help to create a complex system in a more organized and efficient way instead of building everything from scratch.</description>
    </item>
  </channel>
</rss>