<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>UVM Phases | Home</title>
<meta name="keywords" content="uvm">
<meta name="description" content="UVM Framework Directory
In UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.
Figure 1: UVM Phases
The phases can be caterogised as time consumed phases and non-time consumed phase.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.28ee19e1ed9d982499c62390d2acb416195f5655651bae2a84b5090fab8908e0.css" integrity="sha256-KO4Z4e2dmCSZxiOQ0qy0FhlfVlVlG64qhLUJD6uJCOA=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">


<meta property="og:title" content="UVM Phases" />
<meta property="og:description" content="UVM Framework Directory
In UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.
Figure 1: UVM Phases
The phases can be caterogised as time consumed phases and non-time consumed phase." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/" /><meta property="article:section" content="uvm_directory" />
<meta property="article:published_time" content="2024-09-26T13:20:00-04:00" />
<meta property="article:modified_time" content="2024-09-26T13:20:00-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="UVM Phases"/>
<meta name="twitter:description" content="UVM Framework Directory
In UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.
Figure 1: UVM Phases
The phases can be caterogised as time consumed phases and non-time consumed phase."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Uvm_directories",
      "item": "https://24x7fpga.com/uvm_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "UVM Phases",
      "item": "https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UVM Phases",
  "name": "UVM Phases",
  "description": "UVM Framework Directory\nIn UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.\nFigure 1: UVM Phases\nThe phases can be caterogised as time consumed phases and non-time consumed phase.",
  "keywords": [
    "uvm"
  ],
  "articleBody": "UVM Framework Directory\nIn UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.\nFigure 1: UVM Phases\nThe phases can be caterogised as time consumed phases and non-time consumed phase.*Timed phases* are those that involve consuming simulation time, such as stimulus generation or checking, and are implemented as tasks. On the other hand, non-timed phases do not involve any time consumption, as they perform operations that happen instantaneously in simulation time. These are usually implemented as void functions.\nTimed Phase Non-Timed Phases Run Build Connect End of Elaboration Start of Simulation Extract Check Report Final The UVM phases are grouped into three main categories. These phases help organize the flow of verification tasks, ensuring everything runs smoothly and in the correct order. They are as follows:\nBuild Phase: This is the first stage, where the testbench is configured and all its components are constructed. During this phase, the necessary environment, such as agents and drivers, is set up.\nRun Phase: This is the phase where the actual simulation occurs. The testcases are executed, and time is spent driving signals, applying stimulus, and monitoring responses.\nClean-up Phase: After the simulation, this phase deals with gathering and reporting the results. Any leftover data or processes are cleaned up, and final reports are generated, providing insights into the verification outcome.\nBuild Phase The build phase method does not consume any time. Since it is the first phase among several phases it is executed in zero simulation time.\nBuild Instantiate components and subcomponents. Get and set values for the components being built. All the components are instantiated. Connect All the components are connected via TLM ports. End of Elaboration Necessary display functions such as UVM topology and other configuration settings are completed. Run Phase Start of Simulation Intended banners such as topology or configuration information are displayed. Initial run-time configuration set. Run The run phase is executed after the start of the simulation phase and is used for stimulus generation and checking of the DUT. The run phase is implemented as a task and is executed in-order, in parallel. Figure 2, shows the order of the execution with time. Each stage can be subdivided into pre and post stages to add more flexibility. Figure 1, shows the pre and post stages for all the run phase stages.\nFigure 2: UVM Run Phase\n1. Reset: Reset for the DUT is generated in this phase.\n2. Configure: This phase is used to program the DUT and any memories in the testbench so that is ready for the start of the test case.\n3. Main: This phase is responsible for generating the stimulus and applying it to the DUT. At the end of this phase, all the test cases are completed.\n4. Shutdown: This phase ensures the effects of stimulus generated during the phase have propagated through the DUT.\nClean Up Phase The clean up phases are used to extract information from scoreboards and functional coverage monitors to determine whether the test case has passed or reached its coverage goals.\nExtract Simulation time will no longer advance. Extracts information from the scoreboards and functional coverage monitors to determine whether the test case is passed or failed. Check Analysis of the components to check that the DUT behaved correctly and identify any errors that may have occurred during the simulation process. Report Report the test results and write the results to a log file if necessary. Final End of verification process. ",
  "wordCount" : "622",
  "inLanguage": "en",
  "datePublished": "2024-09-26T13:20:00-04:00",
  "dateModified": "2024-09-26T13:20:00-04:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/uvm_directory/2024_09_26_13_20_13_uvm_phases/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/riscv_directory/2025_02_14_risc_v_directory" title="risc-v">
                    <span> 


                           
                        
                         
                        risc-v</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 15"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>







<script src="https://24x7fpga.com/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      UVM Phases
    </h1>
    <div class="post-meta"><span title='2024-09-26 13:20:00 -0400 EDT'>September 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;622 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><p><a href="/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory/">UVM Framework Directory</a></p>
<p>In UVM, a structured mechanism called UVM phases is used to automate the execution of various components within a testbench. This ensures that the simulation follows a defined sequence, streamlining the process. UVM defines twelve key phases, each with a specific role in the testbench lifecycle. The order of execution for these phases is depicted in Figure 1 below.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/uvm_phases.svg"
         alt="Figure 1: UVM Phases"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->UVM Phases</p>
        </figcaption>
</figure>

<p>The phases can be caterogised as time consumed phases and non-time consumed phase.*Timed phases* are those that involve consuming simulation time, such as stimulus generation or checking, and are implemented as <code>tasks</code>. On the other hand, <strong>non-timed phases</strong> do not involve any time consumption, as they perform operations that happen instantaneously in simulation time. These are usually implemented as <code>void functions</code>.</p>
<table>
<thead>
<tr>
<th>Timed Phase</th>
<th>Non-Timed  Phases</th>
</tr>
</thead>
<tbody>
<tr>
<td>Run</td>
<td>Build</td>
</tr>
<tr>
<td></td>
<td>Connect</td>
</tr>
<tr>
<td></td>
<td>End of Elaboration</td>
</tr>
<tr>
<td></td>
<td>Start of Simulation</td>
</tr>
<tr>
<td></td>
<td>Extract</td>
</tr>
<tr>
<td></td>
<td>Check</td>
</tr>
<tr>
<td></td>
<td>Report</td>
</tr>
<tr>
<td></td>
<td>Final</td>
</tr>
</tbody>
</table>
<p>The UVM phases are grouped into three main categories. These phases help organize the flow of verification tasks, ensuring everything runs smoothly and in the correct order. They are as follows:</p>
<ol>
<li>
<p>Build Phase: This is the first stage, where the testbench is configured and all its components are constructed. During this phase, the necessary environment, such as agents and drivers, is set up.</p>
</li>
<li>
<p>Run Phase: This is the phase where the actual simulation occurs. The testcases are executed, and time is spent driving signals, applying stimulus, and monitoring responses.</p>
</li>
<li>
<p>Clean-up Phase: After the simulation, this phase deals with gathering and reporting the results. Any leftover data or processes are cleaned up, and final reports are generated, providing insights into the verification outcome.</p>
</li>
</ol>
<h2 id="build-phase">Build Phase<a hidden class="anchor" aria-hidden="true" href="#build-phase">#</a></h2>
<p>The build phase method does not consume any time. Since it is the first phase among several phases it is executed in zero simulation time.</p>
<h3 id="build">Build<a hidden class="anchor" aria-hidden="true" href="#build">#</a></h3>
<ul>
<li>Instantiate components and subcomponents.</li>
<li>Get and set values for the components being built.</li>
<li>All the components are instantiated.</li>
</ul>
<h3 id="connect">Connect<a hidden class="anchor" aria-hidden="true" href="#connect">#</a></h3>
<ul>
<li>All the components are connected via TLM ports.</li>
</ul>
<h3 id="end-of-elaboration">End of Elaboration<a hidden class="anchor" aria-hidden="true" href="#end-of-elaboration">#</a></h3>
<ul>
<li>Necessary display functions such as UVM topology and other configuration settings are completed.</li>
</ul>
<h2 id="run-phase">Run Phase<a hidden class="anchor" aria-hidden="true" href="#run-phase">#</a></h2>
<h3 id="start-of-simulation">Start of Simulation<a hidden class="anchor" aria-hidden="true" href="#start-of-simulation">#</a></h3>
<ul>
<li>Intended banners such as topology or configuration information are displayed.</li>
<li>Initial run-time configuration set.</li>
</ul>
<h3 id="run">Run<a hidden class="anchor" aria-hidden="true" href="#run">#</a></h3>
<p>The run phase is executed after the start of the simulation phase and is used for stimulus generation and checking of the DUT. The run phase is implemented as a task and is executed in-order, in parallel. Figure 2, shows the order of the execution with time. Each stage can be subdivided into <code>pre</code> and <code>post</code> stages to add more flexibility. Figure 1, shows the pre and post stages for all the run phase stages.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/run_phase.svg"
         alt="Figure 2: UVM Run Phase"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->UVM Run Phase</p>
        </figcaption>
</figure>

<p><strong>1. Reset:</strong> Reset for the DUT is generated in this phase.</p>
<p><strong>2. Configure:</strong> This phase is used to program the DUT and any memories in the testbench so that is ready for the start of the test case.</p>
<p><strong>3. Main:</strong> This phase is responsible for generating the stimulus and applying it to the DUT. At the end of this phase, all the test cases are completed.</p>
<p><strong>4. Shutdown:</strong> This phase ensures the effects of stimulus generated during the phase have propagated through the DUT.</p>
<h2 id="clean-up-phase">Clean Up Phase<a hidden class="anchor" aria-hidden="true" href="#clean-up-phase">#</a></h2>
<p>The clean up phases are used to extract information from scoreboards and functional coverage monitors to determine whether the test case has passed or reached its coverage goals.</p>
<h3 id="extract">Extract<a hidden class="anchor" aria-hidden="true" href="#extract">#</a></h3>
<ul>
<li>Simulation time will no longer advance.</li>
<li>Extracts information from the scoreboards and functional coverage monitors to determine whether the test case is passed or failed.</li>
</ul>
<h3 id="check">Check<a hidden class="anchor" aria-hidden="true" href="#check">#</a></h3>
<ul>
<li>Analysis of the components to check that the DUT behaved correctly and identify any errors that may have occurred during the simulation process.</li>
</ul>
<h3 id="report">Report<a hidden class="anchor" aria-hidden="true" href="#report">#</a></h3>
<ul>
<li>Report the test results and write the results to a log file if necessary.</li>
</ul>
<h3 id="final">Final<a hidden class="anchor" aria-hidden="true" href="#final">#</a></h3>
<ul>
<li>End of verification process.</li>
</ul>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/uvm/">uvm</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
