<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mealy Machine and Moore Machine | Home</title>
<meta name="keywords" content="rtl">
<meta name="description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Finite State Machine A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.
Components of an FSM: States: Unique condition that define the state of the system.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/rtl_directory/2024_08_05_16_07_25_mealy_machine_and_moore_machine/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.19a7d7ba8a856bc3605fc7ca61a989cac3905b8b7707571254a3f97e6b40052a.css" integrity="sha256-GafXuoqFa8NgX8fKYamJysOQW4t3B1cSVKP5fmtABSo=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">

<meta property="og:title" content="Mealy Machine and Moore Machine" />
<meta property="og:description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Finite State Machine A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.
Components of an FSM: States: Unique condition that define the state of the system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/rtl_directory/2024_08_05_16_07_25_mealy_machine_and_moore_machine/" /><meta property="article:section" content="rtl_directory" />
<meta property="article:published_time" content="2024-08-05T16:07:00-04:00" />
<meta property="article:modified_time" content="2024-08-05T16:07:00-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mealy Machine and Moore Machine"/>
<meta name="twitter:description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Finite State Machine A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.
Components of an FSM: States: Unique condition that define the state of the system."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Rtl_directories",
      "item": "https://24x7fpga.com/rtl_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Mealy Machine and Moore Machine",
      "item": "https://24x7fpga.com/rtl_directory/2024_08_05_16_07_25_mealy_machine_and_moore_machine/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mealy Machine and Moore Machine",
  "name": "Mealy Machine and Moore Machine",
  "description": "Design \u0026ndash; Testbench \u0026ndash; RTL Design Directory\nFinite State Machine A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.\nComponents of an FSM: States: Unique condition that define the state of the system.",
  "keywords": [
    "rtl"
  ],
  "articleBody": "Design – Testbench – RTL Design Directory\nFinite State Machine A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.\nComponents of an FSM: States: Unique condition that define the state of the system. Inputs: Inputs are signals or data that trigger a state change. Transitions: Rules that dictate how the FSM moves from one state to another based on inputs. Outputs: Values that the FSM produces, based either on the state (Moore) or state and inputs (Mealy). The two main types of FSMs:\nMealy Machine: The output is a function of the present state and the present input. Moore Machine: The output is a function of only the present state. Mealy Machine In a Mealy machine, the output depends on both the current state and the input. This means the system reacts instantly to input changes, with the output potentially updating even before transitioning to a new state. As inputs change, the machine can adjust its behavior dynamically, making it responsive and efficient in scenarios where quick reactions are needed.\nFigure 1: Mealy Machine\nAs shown in Figure 1, the diagram illustrates two primary components: the state register and the combinational logic. The state register stores the current state of the system. It updates on each clock cycle and serves as a reference for the machine’s current condition. The combinational logic block takes both the output from the state register (representing the current state) and the external input signals. Together, these determine both the next state of the system and the output at that moment.\nMoore Machine In a Moore machine, the output is determined entirely by the current state of the system, not the inputs. This means that the output only updates when the system transitions from one state to another. As a result, the output remains stable and consistent within each state, making the behavior of the Moore machine more predictable and easier to manage.\nFigure 2: Moore Machine\nIn a Moore machine, the system’s output is determined solely by its current state, as shown in Figure 2. The combinational logic block calculates the output based purely on the value stored in the state register, independent of any external inputs.\nDifference between Mealy and Moore FSM Mealy Machine Moore Machine Output Logic Complexity May require complex output logic, since it depends on both input and state Has simpler output logic, depending only on the current state Output Dependency Output depends on both the input and the present state Output depends solely on the present state Output Response Time Output changes immediately when the input changes Output changes only when the state changes Hardware Requirements Typically requires less hardware for circuit implementation Usually requires more hardware for circuit implementation Output Timing Generates asynchronous outputs Generates synchronous outputs State Requirement Generally requires fewer or the same number of states as a Moore machine Often requires more states than a Mealy machine Coding Style Following a good coding style is essential for creating clear, reliable, and maintainable RTL designs. There are a few key approaches and coding practices commonly used in FSM design.\nState Encoding State encoding in a Finite State Machine (FSM) refers to how each state is represented using binary values in the hardware. The choice of encoding has a significant impact on the overall design, affecting factors like complexity, speed, and resource usage. Different encoding techniques can be chosen based on specific design needs, whether the focus is on performance, power efficiency, or minimizing hardware area.\nBinary: In a Binary or sequential encoding scheme, each state is assigned a unique binary number. For an n FSM state, the total number of registers required is log2(n) bits. parameter START = 2'b00, STAT1 = 2'b01, STAT2 = 2'b10, END = 2'b11; reg [1:0] st_reg, st_nxt; Onehot Encoded: In the Onehot encoded scheme, each state is represented by a unique binary value where only one bit is high (hot) at any given time. For an n FSM states, the required state register is n bits. parameter START = 4'b0001, STAT1 = 4'b0010, STAT2 = 4'b0100, END = 4'b1000; reg [3:0] st_reg, st_nxt; Gray Code: In the Gray Code encoding scheme, each state is encoded in such a way that only one-bit changes between any consecutive states. parameter START = 2'b00, STAT1 = 2'b01, STAT2 = 2'b11, END = 2'b10; reg [1:0] st_reg, st_nxt; Encoding style Bits Required Pros Cons Binary log2(n) Minimizes flip-flops Complex next-state logic One-Hot n Simple and fast Requries as many registers as bits Gray Code log2(n) Reduces switching noise More Complex design When implementing a Finite State Machine (FSM) on an FPGA, the one-hot encoding scheme is often recommended. This approach is well-suited for FPGAs as they pack a large number of flip-flops (FFs), which allow for straightforward and efficient state management. One-hot encoding simplifies the state transitions and can lead to faster operation because each state is represented by a single flip-flop, making the logic for state transitions and output straightforward.\nIn contrast, when designing for Application-Specific Integrated Circuits (ASICs), flip-flops come at a premium in terms of both area and cost. Therefore, careful consideration must be given to the state encoding scheme used. In ASIC designs, binary or Gray code encoding might be preferred due to their reduced flip-flop requirements. This choice helps in minimizing the hardware footprint and managing costs, although it can result in more complex state transition logic.\nBy selecting the appropriate state encoding based on the target technology—FPGA or ASIC—you can optimize the FSM design for both performance and resource efficiency.\nDesign Practices for Synthesizable Finite State Machines (FSMs) When designing a synthesizable Finite State Machine (FSM), there are several approaches you can take, each with its own advantages and use cases. Here are three common practices:\nOne Always Block In this approach, both state transitions and output logic are handled within a single always block. This method integrates the state register update and output generation into one place, simplifying the design and making the FSM easier to understand.\nAdvantages\nSimplifies the FSM design by placing all logic in a single always block. Makes the design easier to read and manage, especially for smaller FSMs. Example Use Case\nIdeal for straightforward FSMs where combining logic does not increase complexity. Two Always Blocks This practice separates the FSM into two always blocks: one for state transitions and another for output logic. The first block handles state updates based on the clock and reset signals, while the second block generates outputs based on the current state and inputs.\nAdvantages\nEnhances clarity by separating state transitions from output logic. Example Use Case\nSuitable for medium complexity FSMs where separation of concerns improves design readability and manageability. Three Always Blocks: In this approach, the FSM is divided into three distinct always blocks: one for state register updates, one for next-state logic, and one for output logic. The third always is implemented for registered outputs of the FSM.\nAdvantages\nRegistering the outputs ensures that the output is glitch-free. Example Use Case\nBest for complex FSMs where a glitch-free output is necessary. Choosing the right practice depends on the complexity of your FSM and your design goals. Each approach offers different levels of simplicity, and clarity, helping you tailor your design to meet specific needs effectively.\nPoints to Remember Use parameters to define state encodings. Make state and next state declarations right after the parameter declarations. Code all sequential always block using nonblocking assignments and all combinational always block using blocking assignments to avoid Verilog simulation race conditions. After defining the state encodings at the top of the FSM module, never use the state encodings again in the RTL code. Avoid the one always block FSM coding style unless required. It is recommended to use a two always block coding style to code FSM designs with combinational outputs. This style is efficient and easy to code and can also easily handle Mealy FSM designs. Use a three always block coding style to code FSM designs with registered outputs for a glitch-free output. References Cummings, Clifford E. “The fundamentals of efficient synthesizable finite state machine design using nc-verilog and buildgates.” Proceedings of International Cadence Usergroup Conference. 2002. Cummings, Clifford E. “Synthesizable Finite State Machine Design Techniques Using the New SystemVerilog 3.0 Enhancements.” SNUG (Synopsys Users Group San Jose, CA 2003) Proceedings (2003). ",
  "wordCount" : "1433",
  "inLanguage": "en",
  "datePublished": "2024-08-05T16:07:00-04:00",
  "dateModified": "2024-08-05T16:07:00-04:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/rtl_directory/2024_08_05_16_07_25_mealy_machine_and_moore_machine/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 20"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>







<script src="https://24x7fpga.com/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Mealy Machine and Moore Machine
    </h1>
    <div class="post-meta"><span title='2024-08-05 16:07:00 -0400 EDT'>August 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1433 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><p><a href="https://github.com/24x7fpga/iVerilog/tree/master/design/fsm_seq">Design</a> &ndash; <a href="https://github.com/24x7fpga/iVerilog/blob/master/tb_design/tb_fsm_seq/tb_fsm_seq.v">Testbench</a> &ndash; <a href="/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/">RTL Design Directory</a></p>
<h2 id="finite-state-machine">Finite State Machine<a hidden class="anchor" aria-hidden="true" href="#finite-state-machine">#</a></h2>
<p>A Finite State Machine (FSM) is a mathematical model used to represent a system with a finite number of states and a set of transitions between those states, driven by inputs. Each state can be considered as a decision node, where the decision is based on the input and or the input and the current decision tree node.</p>
<h4 id="components-of-an-fsm">Components of an FSM:<a hidden class="anchor" aria-hidden="true" href="#components-of-an-fsm">#</a></h4>
<ul>
<li>States: Unique condition that define the state of the system.</li>
<li>Inputs: Inputs are signals or data that trigger a state change.</li>
<li>Transitions: Rules that dictate how the FSM moves from one state to another based on inputs.</li>
<li>Outputs: Values that the FSM produces, based either on the state (Moore) or state and inputs (Mealy).</li>
</ul>
<h2 id="d41d8c"><a hidden class="anchor" aria-hidden="true" href="#d41d8c">#</a></h2>
<p>The two main types of FSMs:</p>
<ol>
<li>Mealy Machine: The output is a function of the present state and the present input.</li>
<li>Moore Machine: The output is a function of only the present state.</li>
</ol>
<h3 id="mealy-machine">Mealy Machine<a hidden class="anchor" aria-hidden="true" href="#mealy-machine">#</a></h3>
<p>In a Mealy machine, the output depends on both the current state and the input. This means the system reacts instantly to input changes, with the output potentially updating even before transitioning to a new state. As inputs change, the machine can adjust its behavior dynamically, making it responsive and efficient in scenarios where quick reactions are needed.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/mealy_machine.svg"
         alt="Figure 1: Mealy Machine"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->Mealy Machine</p>
        </figcaption>
</figure>

<p>As shown in Figure 1, the diagram illustrates two primary components: the state register and the combinational logic. The <code>state register</code> stores the current state of the system. It updates on each clock cycle and serves as a reference for the machine&rsquo;s current condition. The <code>combinational logic</code> block takes both the output from the state register (representing the current state) and the external input signals. Together, these determine both the next state of the system and the output at that moment.</p>
<h3 id="moore-machine">Moore Machine<a hidden class="anchor" aria-hidden="true" href="#moore-machine">#</a></h3>
<p>In a Moore machine, the output is determined entirely by the current state of the system, not the inputs. This means that the output only updates when the system transitions from one state to another. As a result, the output remains stable and consistent within each state, making the behavior of the Moore machine more predictable and easier to manage.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/moore_machine.svg"
         alt="Figure 2: Moore Machine"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->Moore Machine</p>
        </figcaption>
</figure>

<p>In a Moore machine, the system&rsquo;s output is determined solely by its current state, as shown in Figure 2. The <code>combinational logic</code> block calculates the output based purely on the value stored in the state register, independent of any external inputs.</p>
<h3 id="difference-between-mealy-and-moore-fsm">Difference between Mealy and Moore FSM<a hidden class="anchor" aria-hidden="true" href="#difference-between-mealy-and-moore-fsm">#</a></h3>
<table>
<thead>
<tr>
<th></th>
<th>Mealy Machine</th>
<th>Moore Machine</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Output Logic Complexity</strong></td>
<td>May require complex output logic, since it depends on both input and state</td>
<td>Has simpler output logic, depending only on the current state</td>
</tr>
<tr>
<td><strong>Output Dependency</strong></td>
<td>Output depends on both the input and the present state</td>
<td>Output depends solely on the present state</td>
</tr>
<tr>
<td><strong>Output Response Time</strong></td>
<td>Output changes immediately when the input changes</td>
<td>Output changes only when the state changes</td>
</tr>
<tr>
<td><strong>Hardware Requirements</strong></td>
<td>Typically requires less hardware for circuit implementation</td>
<td>Usually requires more hardware for circuit implementation</td>
</tr>
<tr>
<td><strong>Output Timing</strong></td>
<td>Generates asynchronous outputs</td>
<td>Generates synchronous outputs</td>
</tr>
<tr>
<td><strong>State Requirement</strong></td>
<td>Generally requires fewer or the same number of states as a Moore machine</td>
<td>Often requires more states than a Mealy machine</td>
</tr>
</tbody>
</table>
<h3 id="coding-style">Coding Style<a hidden class="anchor" aria-hidden="true" href="#coding-style">#</a></h3>
<p>Following a good coding style is essential for creating clear, reliable, and maintainable RTL designs. There are a few key approaches and coding practices commonly used in FSM design.</p>
<h4 id="state-encoding">State Encoding<a hidden class="anchor" aria-hidden="true" href="#state-encoding">#</a></h4>
<p>State encoding in a Finite State Machine (FSM) refers to how each state is represented using binary values in the hardware. The choice of encoding has a significant impact on the overall design, affecting factors like complexity, speed, and resource usage. Different encoding techniques can be chosen based on specific design needs, whether the focus is on performance, power efficiency, or minimizing hardware area.</p>
<ul>
<li><strong>Binary:</strong> In a Binary or sequential encoding scheme, each state is assigned a unique binary number. For an <code>n</code> FSM state, the total number of registers required is <code>log2(n)</code> bits.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> START <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b00</span>,
</span></span><span style="display:flex;"><span>          STAT1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b01</span>,
</span></span><span style="display:flex;"><span>          STAT2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b10</span>,
</span></span><span style="display:flex;"><span>          END   <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b11</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] st_reg, st_nxt;
</span></span></code></pre></div><ul>
<li><strong>Onehot Encoded:</strong> In the Onehot encoded scheme, each state is represented by a unique binary value where only one bit is <code>high (hot)</code> at any given time. For an <code>n</code> FSM states, the required state register is <code>n</code> bits.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> START <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b0001</span>,
</span></span><span style="display:flex;"><span>          STAT1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b0010</span>,
</span></span><span style="display:flex;"><span>          STAT2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b0100</span>,
</span></span><span style="display:flex;"><span>          END   <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b1000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] st_reg, st_nxt;
</span></span></code></pre></div><ul>
<li><strong>Gray Code:</strong> In the Gray Code encoding scheme, each state is encoded in such a way that only one-bit changes between any consecutive states.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> START <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b00</span>,
</span></span><span style="display:flex;"><span>          STAT1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b01</span>,
</span></span><span style="display:flex;"><span>          STAT2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b11</span>,
</span></span><span style="display:flex;"><span>          END   <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#ae81ff">&#39;b10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] st_reg, st_nxt;
</span></span></code></pre></div><h2 id="d41d8c"><a hidden class="anchor" aria-hidden="true" href="#d41d8c">#</a></h2>
<table>
<thead>
<tr>
<th>Encoding style</th>
<th>Bits Required</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary</td>
<td>log2(n)</td>
<td>Minimizes flip-flops</td>
<td>Complex next-state logic</td>
</tr>
<tr>
<td>One-Hot</td>
<td>n</td>
<td>Simple and fast</td>
<td>Requries as many registers as bits</td>
</tr>
<tr>
<td>Gray Code</td>
<td>log2(n)</td>
<td>Reduces switching noise</td>
<td>More Complex design</td>
</tr>
</tbody>
</table>
<p>When implementing a Finite State Machine (FSM) on an FPGA, the one-hot encoding scheme is often recommended. This approach is well-suited for FPGAs as they pack a large number of flip-flops (FFs), which allow for straightforward and efficient state management. One-hot encoding simplifies the state transitions and can lead to faster operation because each state is represented by a single flip-flop, making the logic for state transitions and output straightforward.</p>
<p>In contrast, when designing for Application-Specific Integrated Circuits (ASICs), flip-flops come at a premium in terms of both area and cost. Therefore, careful consideration must be given to the state encoding scheme used. In ASIC designs, binary or Gray code encoding might be preferred due to their reduced flip-flop requirements. This choice helps in minimizing the hardware footprint and managing costs, although it can result in more complex state transition logic.</p>
<p>By selecting the appropriate state encoding based on the target technology—FPGA or ASIC—you can optimize the FSM design for both performance and resource efficiency.</p>
<h3 id="design-practices-for-synthesizable-finite-state-machines--fsms">Design Practices for Synthesizable Finite State Machines (FSMs)<a hidden class="anchor" aria-hidden="true" href="#design-practices-for-synthesizable-finite-state-machines--fsms">#</a></h3>
<p>When designing a synthesizable Finite State Machine (FSM), there are several approaches you can take, each with its own advantages and use cases. Here are three common practices:</p>
<h4 id="one-always-block">One Always Block<a hidden class="anchor" aria-hidden="true" href="#one-always-block">#</a></h4>
<p>In this approach, both state transitions and output logic are handled within a single always block. This method integrates the state register update and output generation into one place, simplifying the design and making the FSM easier to understand.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Advantages</p>
<ul>
<li>Simplifies the FSM design by placing all logic in a single always block.</li>
<li>Makes the design easier to read and manage, especially for smaller FSMs.</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Example Use Case</p>
<ul>
<li>Ideal for straightforward FSMs where combining logic does not increase complexity.</li>
</ul>
</li>
</ul>
<h4 id="two-always-blocks">Two Always Blocks<a hidden class="anchor" aria-hidden="true" href="#two-always-blocks">#</a></h4>
<p>This practice separates the FSM into two always blocks: one for state transitions and another for output logic. The first block handles state updates based on the clock and reset signals, while the second block generates outputs based on the current state and inputs.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Advantages</p>
<ul>
<li>Enhances clarity by separating state transitions from output logic.</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Example Use Case</p>
<ul>
<li>Suitable for medium complexity FSMs where separation of concerns improves design readability and manageability.</li>
</ul>
</li>
</ul>
<h4 id="three-always-blocks">Three Always Blocks:<a hidden class="anchor" aria-hidden="true" href="#three-always-blocks">#</a></h4>
<p>In this approach, the FSM is divided into three distinct always blocks: one for state register updates, one for next-state logic, and one for output logic. The third always is implemented for registered outputs of the FSM.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Advantages</p>
<ul>
<li>Registering the outputs ensures that the output is glitch-free.</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Example Use Case</p>
<ul>
<li>Best for complex FSMs where a glitch-free output is necessary.</li>
</ul>
<p>Choosing the right practice depends on the complexity of your FSM and your design goals. Each approach offers different levels of simplicity, and clarity, helping you tailor your design to meet specific needs effectively.</p>
</li>
</ul>
<h3 id="points-to-remember">Points to Remember<a hidden class="anchor" aria-hidden="true" href="#points-to-remember">#</a></h3>
<ol>
<li>Use parameters to define state encodings.</li>
<li>Make <code>state</code> and <code>next state</code> declarations right after the parameter declarations.</li>
<li>Code all sequential always block using nonblocking assignments and all combinational always block using blocking assignments to avoid Verilog simulation race conditions.</li>
<li>After defining the state encodings at the top of the FSM module, never use the state encodings again in the RTL code.</li>
<li>Avoid the one always block FSM coding style unless required.</li>
<li>It is recommended to use a two always block coding style to code FSM designs with combinational outputs. This style is efficient and easy to code and can also easily handle Mealy FSM designs.</li>
<li>Use a three always block coding style to code FSM designs with registered outputs for a glitch-free output.</li>
</ol>
<h3 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<ol>
<li><a href="http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf">Cummings, Clifford E. &ldquo;The fundamentals of efficient synthesizable finite state machine design using nc-verilog and buildgates.&rdquo; Proceedings of International Cadence Usergroup Conference. 2002.</a></li>
<li><a href="http://www.sunburst-design.com/papers/CummingsSNUG2003SJ_SystemVerilogFSM_rev1_1.pdf">Cummings, Clifford E. &ldquo;Synthesizable Finite State Machine Design Techniques Using the New SystemVerilog 3.0 Enhancements.&rdquo; SNUG (Synopsys Users Group San Jose, CA 2003) Proceedings (2003).</a></li>
</ol>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/rtl/">rtl</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
