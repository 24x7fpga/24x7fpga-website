<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Asynchronous FIFO | Home</title>
<meta name="keywords" content="rtl">
<meta name="description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Asynchronous FIFO An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/rtl_directory/2024_09_07_10_52_50_asynchronous_fifo/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.19a7d7ba8a856bc3605fc7ca61a989cac3905b8b7707571254a3f97e6b40052a.css" integrity="sha256-GafXuoqFa8NgX8fKYamJysOQW4t3B1cSVKP5fmtABSo=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">

<meta property="og:title" content="Asynchronous FIFO" />
<meta property="og:description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Asynchronous FIFO An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/rtl_directory/2024_09_07_10_52_50_asynchronous_fifo/" /><meta property="article:section" content="rtl_directory" />
<meta property="article:published_time" content="2024-09-07T10:52:00-04:00" />
<meta property="article:modified_time" content="2024-09-07T10:52:00-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Asynchronous FIFO"/>
<meta name="twitter:description" content="Design &ndash; Testbench &ndash; RTL Design Directory
Asynchronous FIFO An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Rtl_directories",
      "item": "https://24x7fpga.com/rtl_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Asynchronous FIFO",
      "item": "https://24x7fpga.com/rtl_directory/2024_09_07_10_52_50_asynchronous_fifo/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Asynchronous FIFO",
  "name": "Asynchronous FIFO",
  "description": "Design \u0026ndash; Testbench \u0026ndash; RTL Design Directory\nAsynchronous FIFO An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral.",
  "keywords": [
    "rtl"
  ],
  "articleBody": "Design – Testbench – RTL Design Directory\nAsynchronous FIFO An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral.\nThe primary role of the asynchronous FIFO is to ensure smooth data flow between these distinct clock domains, preventing data loss during transmission. By temporarily storing data in the buffer, the asynchronous FIFO allows the system to handle varying clock speeds without missing any critical data.\nHandling Pointer Synchronization In an asynchronous FIFO, the write pointer is updated in the write clock domain, while the read pointer is updated in the read clock domain. The full flag is generated based on the write clock, and the empty flag is generated based on the read clock. Challenge arises when comparing the write and read pointers to generate the full and empty flags, as the pointers are updated in different clock domains from each other. This is different from a synchronous FIFO, where both pointers are updated in the same clock domain, making comparisons straightforward.\nThe key issue with asynchronous FIFOs is metastability—a situation where the design works fine in simulations but fails in real hardware due to timing violations when crossing clock domains. This can lead to unreliable data handling or system failures. One of many solutions for clock-domain crossing is to use a two-flop synchronizer.\nWhen implementing a two-flop synchronizer in asynchronous FIFOs, one critical constraint is ensuring that only one bit of the data signal changes at a time while crossing from one clock domain to another. This minimizes the risk of metastability. To meet this constraint, gray code is used instead of a traditional binary counter for the read and write pointers. Unlike binary counters, where multiple bits can change simultaneously, gray code ensures that only a single bit changes with each transition. This makes Gray code ideal for safely synchronizing data between different clock domains, providing a robust solution for clock domain crossings in digital design.\nGray Code Counter Detailed design for binary to Gray code and Gray to binary conversion here. From the table below, you’ll notice that Gray code exhibits a mirrored symmetry from decimal values 8 to 15. This makes Gray code a symmetric code, except for the most significant bit (MSB).\nDecimal system Binary System Gray Code 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 For instance, if the FIFO depth is eight, the three least significant bits (LSBs) of the Gray code are used as the address to access FIFO locations. The MSB, on the other hand, is crucial for checking the FIFO full condition. Hence, for a N-depth FIFO (from N-1 to 0), the number of bits required to represent the pointer is log₂(N) + 1. For example, for a 8-depth FIFO (0 to 7 memory location), log₂(8) + 1 = 3 + 1 = 4 bits are required for pointer representation.\nTwo-Flop Synchronizer A two-flop synchronizer consists of two flip-flops arranged in series without any combinational logic in between. By placing these flip-flops close together, the design minimizes propagation delay, improving the reliability of data transfer between asynchronous clock domains.\nThe synchronizer circuit ensures reliable data transfer between clock domains by sampling the incoming signal with the receiving clock, aligning it to the timing of the destination clock domain. This helps prevent metastability and ensures the stable operation of the system. A two-flop synchronizer is shown in Figure 1.\nFigure 1: Two-Flop Synchronizer\nIn a two-flip-flop synchronizer, the first flip-flop captures the asynchronous input signal as it enters the new clock domain. This signal then remains in the first stage for a full clock cycle, allowing any metastability in the signal to settle. After this cycle, the stabilized signal is passed to a second flip-flop, where it is sampled again by the same clock. The second-stage flip-flop ensures that the signal is now stable, valid, and fully synchronized with the new clock domain. This process helps eliminate timing issues when signals transition between different clock domains.\nalways@(posedge sync_clk) if(!sync_rst) {sync_out, sync_temp} \u003c= 'h0; else {sync_out, sync_temp} \u003c= {sync_temp, sync_in}; Two-flop synchronizer design can be found here.\nFIFO Design When working on a complex design, it’s a good practice to break it down into smaller, manageable parts. This not only simplifies the design process but also makes it easier to understand and debug. In Figure 2, you can see the complete design of an asynchronous FIFO, divided into its essential components for clarity.\nFigure 2: Asynchronous FIFO\nPointer Generation and Comparision Pointer generation and comparison in asynchronous FIFOs involve tracking the read and write pointer across different clock domains.\nWrite Pointer All the variables discussed in this section are generated within the write clock domain, ensuring they are synchronized and operate in alignment with the write-side logic of the asynchronous FIFO.\nWrite Address: An N-bit binary counter is used to generate the address for writing to the FIFO when it’s not full and the write enable signal is high.\nWrite Pointer: A binary-to-Gray code converter is implemented to translate the write address from binary to Gray code, allowing for synchronization with the read clock domain.\nFull Flag: The write pointer (in Gray code) is compared with the read pointer (also in Gray code) from the two-flop synchronizer to generate the full flag. If the first two most significant bits (MSBs) of the write and read pointers are inverted, and the remaining bits (from the 3rd MSB to the LSB) are the same, the full flag is set high, indicating the FIFO is full.\nN = FIFO Address Width\n// write address counter: binary counter assign wr_bin_nxt = (wr_en \u0026\u0026 !wr_ful_reg) ? (wr_bin_reg + 'h1) : wr_bin_reg; // write pointer counter: gray counter assign wr_gry_nxt = (wr_bin_nxt \u003e\u003e 1) ^ wr_bin_nxt; // full condition assign wr_ful_nxt = (wr_gry_nxt == {~r2w_rd_ptr[`ADDR_WIDTH:`ADDR_WIDTH-1], r2w_rd_ptr[`ADDR_WIDTH-2:0]}); // write address and write pointer assign wr_addr = wr_bin_reg[`ADDR_WIDTH-1:0]; assign wr_ptr = wr_gry_reg; Note: The wr_gry_nxt i.e., is the next write pointer in Gray code is compared against the write clock synchronized read pointer r2w_rd_ptr in Gray code.\nComplete code for the write pointer design can be found here.\nRead Pointer All the variables discussed in this section are generated within the read clock domain, ensuring they are synchronized and operate in alignment with the read-side logic of the asynchronous FIFO.\nRead Address: An N-bit binary counter is used to generate the address forreading from FIFO when it’s not empty and the read enable signal is high.\nRead Pointer: A binary-to-Gray code converter is implemented to translate the read address from binary to Gray code, allowing for synchronization with the write clock domain.\nEmpty Flag: The empty signal is set when the write pointer is equal to the read pointer (both in Gray code).\n// read address counter: binary counter assign rd_bin_nxt = (rd_en \u0026\u0026 !rd_emp_reg) ? (rd_bin_reg + 'h1) : rd_bin_reg; // read pointer counter: gray counter assign rd_gry_nxt = (rd_bin_nxt\u003e\u003e1) ^ rd_bin_nxt; // empty condition assign rd_emp_nxt = (rd_gry_nxt == w2r_wr_ptr); // read address and read pointer assign rd_addr = rd_bin_reg[`ADDR_WIDTH-1:0]; assign rd_ptr = rd_gry_reg; Note: The rd_gry_nxt i.e., is the next read pointer in Gray code is compared against the read clock synchronized write pointer w2r_wr_ptr in Gray code.\nComplete code for read pointer design can be found here.\nAsynchronous FIFO Depth Calculation When designing a FIFO, knowing the read clock domain’s frequency and the write burst length is crucial for calculating the required FIFO depth. Follow these steps to determine the appropriate depth:\nCalculate the time to write one data item: Determine how long it takes to write a single data item into the FIFO buffer, based on the write clock speed.\nCalculate the total write time for the data burst: Multiply the time per data item by the total number of data items in the burst to find the total time required to write the entire burst.\nDetermine how many data items can be read during the write duration: Based on the read clock frequency, calculate how many data items can be read from the FIFO during the total write time.\nCalculate the minimum FIFO depth: Subtract the number of items read during the write duration from the burst length. The difference gives you the minimum FIFO depth required to ensure no data loss or overflow during operation.\nAn excellent article that explains FIFO depth calculation in detail can be found here.\nReference Cummings, Clifford E. “Synthesis and scripting techniques for designing multi-asynchronous clock designs.” SNUG 2001 (Synopsys Users Group Conference, San Jose, CA, 2001) User Papers. 2001. Cummings, Clifford E. “Simulation and synthesis techniques for asynchronous FIFO design.” SNUG 2002 (Synopsys Users Group Conference, San Jose, CA, 2002) User Papers. Vol. 281. 2002. C. Cummings, P. Alfke, “Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons” SNUG, 2002. ",
  "wordCount" : "1549",
  "inLanguage": "en",
  "datePublished": "2024-09-07T10:52:00-04:00",
  "dateModified": "2024-09-07T10:52:00-04:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/rtl_directory/2024_09_07_10_52_50_asynchronous_fifo/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 20"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>

<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Asynchronous FIFO
    </h1>
    <div class="post-meta"><span title='2024-09-07 10:52:00 -0400 EDT'>September 7, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1549 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><p><a href="https://github.com/24x7fpga/iVerilog/tree/master/design/fifo_asyn">Design</a> &ndash; <a href="https://github.com/24x7fpga/iVerilog/tree/master/tb_design/tb_fifo_asyn">Testbench</a> &ndash; <a href="/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/">RTL Design Directory</a></p>
<h2 id="asynchronous-fifo">Asynchronous FIFO<a hidden class="anchor" aria-hidden="true" href="#asynchronous-fifo">#</a></h2>
<p>An Asynchronous FIFO is a type of buffer where the write and read operations are controlled by different or unsynchronized clock signals. This makes it ideal for digital systems where data is transferred between components running at different speeds, such as when data is transmitted from a peripheral device to a CPU operating at a different clock frequency than that of the peripheral.</p>
<p>The primary role of the asynchronous FIFO is to ensure smooth data flow between these distinct clock domains, preventing data loss during transmission. By temporarily storing data in the buffer, the asynchronous FIFO allows the system to handle varying clock speeds without missing any critical data.</p>
<h3 id="handling-pointer-synchronization">Handling Pointer Synchronization<a hidden class="anchor" aria-hidden="true" href="#handling-pointer-synchronization">#</a></h3>
<p>In an asynchronous FIFO, the <code>write pointer</code> is updated in the write clock domain, while the <code>read pointer</code> is updated in the read clock domain. The <code>full flag</code> is generated based on the write clock, and the <code>empty flag</code> is generated based on the read clock. Challenge arises when comparing the write and read pointers to generate the full and empty flags, as the pointers are updated in different clock domains from each other. This is different from a synchronous FIFO, where both pointers are updated in the same clock domain, making comparisons straightforward.</p>
<p>The key issue with asynchronous FIFOs is metastability—a situation where the design works fine in simulations but fails in real hardware due to timing violations when crossing clock domains. This can lead to unreliable data handling or system failures. One of many solutions for clock-domain crossing is to use a <code>two-flop synchronizer</code>.</p>
<p>When implementing a <code>two-flop synchronizer</code> in asynchronous FIFOs, one critical constraint is ensuring that only one bit of the data signal changes at a time while crossing from one clock domain to another. This minimizes the risk of metastability. To meet this constraint, gray code is used instead of a traditional binary counter for the read and write pointers. Unlike binary counters, where multiple bits can change simultaneously, gray code ensures that only a single bit changes with each transition. This makes Gray code ideal for safely synchronizing data between different clock domains, providing a robust solution for clock domain crossings in digital design.</p>
<h4 id="gray-code-counter">Gray Code Counter<a hidden class="anchor" aria-hidden="true" href="#gray-code-counter">#</a></h4>
<p>Detailed design for binary to Gray code and Gray to binary conversion <a href="https://24x7fpga.com/rtl_directory/2024_07_18_21_58_46_code_converter/">here</a>. From the table below, you’ll notice that Gray code exhibits a mirrored symmetry from decimal values 8 to 15. This makes Gray code a symmetric code, except for the most significant bit (MSB).</p>
<table>
<thead>
<tr>
<th>Decimal system</th>
<th>Binary System</th>
<th>Gray Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0110</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>0111</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>0101</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>0100</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1100</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1101</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>1111</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
<td>1110</td>
</tr>
<tr>
<td>12</td>
<td>1100</td>
<td>1010</td>
</tr>
<tr>
<td>13</td>
<td>1101</td>
<td>1011</td>
</tr>
<tr>
<td>14</td>
<td>1110</td>
<td>1001</td>
</tr>
<tr>
<td>15</td>
<td>1111</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>For instance, if the FIFO depth is eight, the three least significant bits (LSBs) of the Gray code are used as the address to access FIFO locations. The MSB, on the other hand, is crucial for checking the FIFO full condition. Hence, for a N-depth FIFO (from N-1 to 0), the number of bits required to represent the pointer is log₂(N) + 1. For example, for a 8-depth FIFO (0 to 7 memory location), log₂(8) + 1 = 3 + 1 = 4 bits are required for pointer representation.</p>
<h4 id="two-flop-synchronizer">Two-Flop Synchronizer<a hidden class="anchor" aria-hidden="true" href="#two-flop-synchronizer">#</a></h4>
<p>A two-flop synchronizer consists of two flip-flops arranged in series without any combinational logic in between. By placing these flip-flops close together, the design minimizes propagation delay, improving the reliability of data transfer between asynchronous clock domains.</p>
<p>The synchronizer circuit ensures reliable data transfer between clock domains by sampling the incoming signal with the receiving clock, aligning it to the timing of the destination clock domain. This helps prevent metastability and ensures the stable operation of the system. A two-flop synchronizer is shown in Figure 1.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/2ff_sync.svg"
         alt="Figure 1: Two-Flop Synchronizer"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->Two-Flop Synchronizer</p>
        </figcaption>
</figure>

<p>In a two-flip-flop synchronizer, the first flip-flop captures the asynchronous input signal as it enters the new clock domain. This signal then remains in the first stage for a full clock cycle, allowing any metastability in the signal to settle. After this cycle, the stabilized signal is passed to a second flip-flop, where it is sampled again by the same clock. The second-stage flip-flop ensures that the signal is now stable, valid, and fully synchronized with the new clock domain. This process helps eliminate timing issues when signals transition between different clock domains.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always</span>@(<span style="color:#66d9ef">posedge</span> sync_clk)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>sync_rst)
</span></span><span style="display:flex;"><span>          {sync_out, sync_temp} <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">&#39;h0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          {sync_out, sync_temp} <span style="color:#f92672">&lt;=</span> {sync_temp, sync_in};
</span></span></code></pre></div><p>Two-flop synchronizer design can be found <a href="https://github.com/24x7fpga/iVerilog/blob/master/design/fifo_asyn/fifo_sync.v">here</a>.</p>
<h3 id="fifo-design">FIFO Design<a hidden class="anchor" aria-hidden="true" href="#fifo-design">#</a></h3>
<p>When working on a complex design, it’s a good practice to break it down into smaller, manageable parts. This not only simplifies the design process but also makes it easier to understand and debug. In Figure 2, you can see the complete design of an asynchronous FIFO, divided into its essential components for clarity.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/asyn_fifo.svg"
         alt="Figure 2: Asynchronous FIFO"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->Asynchronous FIFO</p>
        </figcaption>
</figure>

<h3 id="pointer-generation-and-comparision">Pointer Generation and Comparision<a hidden class="anchor" aria-hidden="true" href="#pointer-generation-and-comparision">#</a></h3>
<p>Pointer generation and comparison in asynchronous FIFOs involve tracking the read and write pointer across different clock domains.</p>
<h4 id="write-pointer">Write Pointer<a hidden class="anchor" aria-hidden="true" href="#write-pointer">#</a></h4>
<p>All the variables discussed in this section are generated within the <code>write clock domain</code>, ensuring they are synchronized and operate in alignment with the write-side logic of the asynchronous FIFO.</p>
<ul>
<li>
<p>Write Address: An N-bit binary counter is used to generate the address for writing to the FIFO when it&rsquo;s not full and the write enable signal is high.</p>
</li>
<li>
<p>Write Pointer: A binary-to-Gray code converter is implemented to translate the write address from binary to Gray code, allowing for synchronization with the read clock domain.</p>
</li>
<li>
<p>Full Flag: The write pointer (in Gray code) is compared with the read pointer (also in Gray code) from the two-flop synchronizer to generate the full flag. If the first two most significant bits (MSBs) of the write and read pointers are inverted, and the remaining bits (from the 3rd MSB to the LSB) are the same, the full flag is set high, indicating the FIFO is full.</p>
</li>
</ul>
<p>N = FIFO Address Width</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// write address counter: binary counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> wr_bin_nxt <span style="color:#f92672">=</span> (wr_en <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>wr_ful_reg) <span style="color:#f92672">?</span> (wr_bin_reg <span style="color:#f92672">+</span> <span style="color:#ae81ff">&#39;h1</span>) <span style="color:#f92672">:</span> wr_bin_reg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// write pointer counter: gray counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> wr_gry_nxt <span style="color:#f92672">=</span> (wr_bin_nxt <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">^</span> wr_bin_nxt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// full condition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> wr_ful_nxt <span style="color:#f92672">=</span>  (wr_gry_nxt <span style="color:#f92672">==</span> {<span style="color:#f92672">~</span>r2w_rd_ptr[<span style="color:#66d9ef">`ADDR_WIDTH</span><span style="color:#f92672">:</span><span style="color:#66d9ef">`ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], r2w_rd_ptr[<span style="color:#66d9ef">`ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// write address and write pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> wr_addr <span style="color:#f92672">=</span> wr_bin_reg[<span style="color:#66d9ef">`ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> wr_ptr  <span style="color:#f92672">=</span> wr_gry_reg;
</span></span></code></pre></div><p>Note: The <code>wr_gry_nxt</code> i.e., is the next write pointer in Gray code is compared against the write clock synchronized read pointer <code>r2w_rd_ptr</code> in Gray code.</p>
<p>Complete code for the write pointer design can be found <a href="https://github.com/24x7fpga/iVerilog/blob/master/design/fifo_asyn/fifo_wr_ptr.v">here</a>.</p>
<h4 id="read-pointer">Read Pointer<a hidden class="anchor" aria-hidden="true" href="#read-pointer">#</a></h4>
<p>All the variables discussed in this section are generated within the <code>read clock domain</code>, ensuring they are synchronized and operate in alignment with the read-side logic of the asynchronous FIFO.</p>
<ul>
<li>
<p>Read Address: An N-bit binary counter is used to generate the address forreading from FIFO when it&rsquo;s not empty and the read enable signal is high.</p>
</li>
<li>
<p>Read Pointer: A binary-to-Gray code converter is implemented to translate the read address from binary to Gray code, allowing for synchronization with the write clock domain.</p>
</li>
<li>
<p>Empty Flag: The empty signal is set when the write pointer is equal to the read pointer (both in Gray code).</p>
</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// read address counter: binary counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> rd_bin_nxt <span style="color:#f92672">=</span> (rd_en <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rd_emp_reg) <span style="color:#f92672">?</span> (rd_bin_reg <span style="color:#f92672">+</span> <span style="color:#ae81ff">&#39;h1</span>) <span style="color:#f92672">:</span> rd_bin_reg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// read pointer counter: gray counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> rd_gry_nxt <span style="color:#f92672">=</span> (rd_bin_nxt<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">^</span> rd_bin_nxt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// empty condition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> rd_emp_nxt <span style="color:#f92672">=</span> (rd_gry_nxt <span style="color:#f92672">==</span> w2r_wr_ptr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// read address and read pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">assign</span> rd_addr  <span style="color:#f92672">=</span> rd_bin_reg[<span style="color:#66d9ef">`ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> rd_ptr   <span style="color:#f92672">=</span> rd_gry_reg;
</span></span></code></pre></div><p>Note: The <code>rd_gry_nxt</code> i.e., is the next read pointer in Gray code is compared against the read clock synchronized write pointer <code>w2r_wr_ptr</code> in Gray code.</p>
<p>Complete code for read pointer design can be found <a href="https://github.com/24x7fpga/iVerilog/blob/master/design/fifo_asyn/fifo_rd_ptr.v">here</a>.</p>
<h3 id="asynchronous-fifo-depth-calculation">Asynchronous FIFO Depth Calculation<a hidden class="anchor" aria-hidden="true" href="#asynchronous-fifo-depth-calculation">#</a></h3>
<p>When designing a FIFO, knowing the read clock domain&rsquo;s frequency and the write burst length is crucial for calculating the required FIFO depth. Follow these steps to determine the appropriate depth:</p>
<ol>
<li>
<p>Calculate the time to write one data item: Determine how long it takes to write a single data item into the FIFO buffer, based on the write clock speed.</p>
</li>
<li>
<p>Calculate the total write time for the data burst: Multiply the time per data item by the total number of data items in the burst to find the total time required to write the entire burst.</p>
</li>
<li>
<p>Determine how many data items can be read during the write duration: Based on the read clock frequency, calculate how many data items can be read from the FIFO during the total write time.</p>
</li>
<li>
<p>Calculate the minimum FIFO depth: Subtract the number of items read during the write duration from the burst length. The difference gives you the minimum FIFO depth required to ensure no data loss or overflow during operation.</p>
</li>
</ol>
<h3 id="d41d8c"><a hidden class="anchor" aria-hidden="true" href="#d41d8c">#</a></h3>
<p>An excellent article that explains FIFO depth calculation in detail can be found <a href="https://hardwaregeeksblog.wordpress.com/wp-content/uploads/2016/12/fifodepthcalculationmadeeasy2.pdf">here</a>.</p>
<h3 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h3>
<ol>
<li><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=47fa3a7c83edfeea24029df12d0ae32fd9ed7610">Cummings, Clifford E. &ldquo;Synthesis and scripting techniques for designing multi-asynchronous clock designs.&rdquo; SNUG 2001 (Synopsys Users Group Conference, San Jose, CA, 2001) User Papers. 2001.</a></li>
<li><a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf">Cummings, Clifford E. &ldquo;Simulation and synthesis techniques for asynchronous FIFO design.&rdquo; SNUG 2002 (Synopsys Users Group Conference, San Jose, CA, 2002) User Papers. Vol. 281. 2002.</a></li>
<li><a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO2.pdf">C. Cummings, P. Alfke, “Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons” SNUG, 2002.</a></li>
</ol>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/rtl/">rtl</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
