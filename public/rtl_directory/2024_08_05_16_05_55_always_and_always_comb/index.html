<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Always@(*) and Always_Comb | Home</title>
<meta name="keywords" content="rtl">
<meta name="description" content="Source &ndash; RTL Design Directory
Always@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we&rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.
Always@(*) In Verilog, the always @(*) construct was introduced to simplify the sensitivity list in combinational logic.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.28ee19e1ed9d982499c62390d2acb416195f5655651bae2a84b5090fab8908e0.css" integrity="sha256-KO4Z4e2dmCSZxiOQ0qy0FhlfVlVlG64qhLUJD6uJCOA=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">


<meta property="og:title" content="Always@(*) and Always_Comb" />
<meta property="og:description" content="Source &ndash; RTL Design Directory
Always@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we&rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.
Always@(*) In Verilog, the always @(*) construct was introduced to simplify the sensitivity list in combinational logic." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/" /><meta property="article:section" content="rtl_directory" />
<meta property="article:published_time" content="2024-08-05T16:05:00-04:00" />
<meta property="article:modified_time" content="2024-08-05T16:05:00-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Always@(*) and Always_Comb"/>
<meta name="twitter:description" content="Source &ndash; RTL Design Directory
Always@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we&rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.
Always@(*) In Verilog, the always @(*) construct was introduced to simplify the sensitivity list in combinational logic."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Rtl_directories",
      "item": "https://24x7fpga.com/rtl_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Always@(*) and Always_Comb",
      "item": "https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Always@(*) and Always_Comb",
  "name": "Always@(*) and Always_Comb",
  "description": "Source \u0026ndash; RTL Design Directory\nAlways@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we\u0026rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.\nAlways@(*) In Verilog, the always @(*) construct was introduced to simplify the sensitivity list in combinational logic.",
  "keywords": [
    "rtl"
  ],
  "articleBody": "Source – RTL Design Directory\nAlways@(*) and Always_Comb In digital design, both always @(*) in Verilog and always_comb in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make always_comb the preferred choice in modern design flows. In this article, we’ll explore these differences and explain why always_comb offers enhanced safety and robustness over always @(*) in SystemVerilog-based designs.\nAlways@(*) In Verilog, the always @(*) construct was introduced to simplify the sensitivity list in combinational logic. Instead of manually specifying every signal in the sensitivity list, always @(*) automatically infers all the signals that are read within the always block. This feature not only saves time but also improves coding efficiency by eliminating potential errors from manually listing signals.\nLimitation Triggered by sensitivity list changes: The always block only executes when there is a change in the signals that are part of the sensitivity list. Incomplete sensitivity list: The block may not infer all necessary signals, leading to potential simulation mismatches. Always_Comb Introduced in System Verilog, the functionality of the always_comb is the same as the always@(*) but it overcomes the limitation of the always(*) block.\nAdvantages Automatically executes at zero simulation time: Ensures the combinational block is triggered at the very start of the simulation. Sensitive to changes within the function: Monitors changes in signals and updates the logic accordingly. Prevents concurrent writes: Ensures that no other processes are allowed to write to the same variables, reducing race conditions. Time constraints: Unlike other blocks, always_comb does not allow time-consuming operations (e.g., #delay), maintaining true combinational behavior. Points to Remember Always use always_comb to model combinational logic for safer and more reliable code. ",
  "wordCount" : "283",
  "inLanguage": "en",
  "datePublished": "2024-08-05T16:05:00-04:00",
  "dateModified": "2024-08-05T16:05:00-04:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/rtl_directory/2024_08_05_16_05_55_always_and_always_comb/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/riscv_directory/2025_02_14_risc_v_directory" title="risc-v">
                    <span> 


                           
                        
                         
                        risc-v</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 15"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>







<script src="https://24x7fpga.com/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Always@(*) and Always_Comb
    </h1>
    <div class="post-meta"><span title='2024-08-05 16:05:00 -0400 EDT'>August 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;283 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><p><a href="https://github.com/24x7fpga/RTL/tree/master/rtl_designs/always_at_comb">Source</a> &ndash; <a href="/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/">RTL Design Directory</a></p>
<h2 id="always-----and-always-comb">Always@(*) and Always_Comb<a hidden class="anchor" aria-hidden="true" href="#always-----and-always-comb">#</a></h2>
<p>In digital design, both <code>always @(*)</code> in Verilog and <code>always_comb</code> in SystemVerilog are commonly used to model combinational logic. While they serve a similar purpose, there are important differences that make <code>always_comb</code> the preferred choice in modern design flows. In this article, we&rsquo;ll explore these differences and explain why always_comb offers enhanced safety and robustness over <code>always @(*)</code> in SystemVerilog-based designs.</p>
<h3 id="always">Always@(*)<a hidden class="anchor" aria-hidden="true" href="#always">#</a></h3>
<p>In Verilog, the <code>always @(*)</code> construct was introduced to simplify the sensitivity list in combinational logic. Instead of manually specifying every signal in the sensitivity list, <code>always @(*)</code> automatically infers all the signals that are read within the always block. This feature not only saves time but also improves coding efficiency by eliminating potential errors from manually listing signals.</p>
<h4 id="limitation">Limitation<a hidden class="anchor" aria-hidden="true" href="#limitation">#</a></h4>
<ul>
<li>Triggered by sensitivity list changes: The always block only executes when there is a change in the signals that are part of the sensitivity list.</li>
<li>Incomplete sensitivity list: The block may not infer all necessary signals, leading to potential simulation mismatches.</li>
</ul>
<h3 id="always-comb">Always_Comb<a hidden class="anchor" aria-hidden="true" href="#always-comb">#</a></h3>
<p>Introduced in System Verilog, the functionality of the <code>always_comb</code> is the same as the <code>always@(*)</code> but it overcomes the limitation of the <code>always(*)</code> block.</p>
<h4 id="advantages">Advantages<a hidden class="anchor" aria-hidden="true" href="#advantages">#</a></h4>
<ul>
<li>Automatically executes at zero simulation time: Ensures the combinational block is triggered at the very start of the simulation.</li>
<li>Sensitive to changes within the function: Monitors changes in signals and updates the logic accordingly.</li>
<li>Prevents concurrent writes: Ensures that no other processes are allowed to write to the same variables, reducing race conditions.</li>
<li>Time constraints: Unlike other blocks, always_comb does not allow time-consuming operations (e.g., #delay), maintaining true combinational behavior.</li>
</ul>
<h3 id="points-to-remember">Points to Remember<a hidden class="anchor" aria-hidden="true" href="#points-to-remember">#</a></h3>
<ol>
<li>Always use <code>always_comb</code> to model combinational logic for safer and more reliable code.</li>
</ol>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/rtl/">rtl</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
