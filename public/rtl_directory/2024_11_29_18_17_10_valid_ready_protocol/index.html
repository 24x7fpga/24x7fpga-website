<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Valid-Ready Protocol | Home</title>
<meta name="keywords" content="rtl">
<meta name="description" content="Source &ndash; RTL Design Directory
The valid-ready protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.
Figure 1: Valid-Ready Flow Control
Guidelines The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system.">
<meta name="author" content="Kiran">
<link rel="canonical" href="https://24x7fpga.com/rtl_directory/2024_11_29_18_17_10_valid_ready_protocol/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.28ee19e1ed9d982499c62390d2acb416195f5655651bae2a84b5090fab8908e0.css" integrity="sha256-KO4Z4e2dmCSZxiOQ0qy0FhlfVlVlG64qhLUJD6uJCOA=" rel="preload stylesheet" as="style">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="icon" href="https://24x7fpga.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://24x7fpga.com/assets/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://24x7fpga.com/assets/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://24x7fpga.com/assets/apple-touch-icon.png">
<link rel="mask-icon" href="https://24x7fpga.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="../../zcustom.css">


<meta property="og:title" content="Valid-Ready Protocol" />
<meta property="og:description" content="Source &ndash; RTL Design Directory
The valid-ready protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.
Figure 1: Valid-Ready Flow Control
Guidelines The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://24x7fpga.com/rtl_directory/2024_11_29_18_17_10_valid_ready_protocol/" /><meta property="article:section" content="rtl_directory" />
<meta property="article:published_time" content="2024-11-29T18:17:00-05:00" />
<meta property="article:modified_time" content="2024-11-29T18:17:00-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Valid-Ready Protocol"/>
<meta name="twitter:description" content="Source &ndash; RTL Design Directory
The valid-ready protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.
Figure 1: Valid-Ready Flow Control
Guidelines The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Rtl_directories",
      "item": "https://24x7fpga.com/rtl_directory/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Valid-Ready Protocol",
      "item": "https://24x7fpga.com/rtl_directory/2024_11_29_18_17_10_valid_ready_protocol/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Valid-Ready Protocol",
  "name": "Valid-Ready Protocol",
  "description": "Source \u0026ndash; RTL Design Directory\nThe valid-ready protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.\nFigure 1: Valid-Ready Flow Control\nGuidelines The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system.",
  "keywords": [
    "rtl"
  ],
  "articleBody": "Source – RTL Design Directory\nThe valid-ready protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.\nFigure 1: Valid-Ready Flow Control\nGuidelines The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system. Let’s break down their behavior:\nA data transfer occurs only when both the valid and ready signals are high simultaneously. This ensures that the producer has valid data to send and the consumer is ready to receive it.\nThe producer asserts the valid signal high whenever valid data is available for transfer. Importantly, the valid signal remains high until the transaction is complete.\nThe valid signal from the producer must be independent of the ready signal from the consumer. This design ensures that the producer can signal the availability of data without waiting for the consumer’s readiness.\nValid-Ready Slice A valid-ready slice is a pipelined register or buffer that temporarily stores data that ensures that data flow in the data path improving timing and handling backpressure effectively.\nA valid-ready slice is a critical component in digital design that enhances the reliability and efficiency of data transfer in a system. Simply put, it is a pipelined register or buffer that temporarily stores data in producer and consumer modules.\nFigure 2: Valid-Ready Slice\nKey Benefits of Valid-Ready Slice Improved Timing: By introducing a pipelined stage, the valid-ready slice helps break down long combinational paths, ensuring the system meets timing requirements in high-speed designs.\nEffective Backpressure Handling: In scenarios where the consumer cannot immediately process incoming data, the valid-ready slice manages the backpressure by regulating the valid and ready signals, preventing data loss or overwrites.\nSeamless Data Flow: The slice ensures smooth data transfer between producer and consumer modules, even when they operate at different speeds or in different clock domains.\nPipelined Data Processing: In a processing pipeline, a slice ensures smooth data flow without overwriting or stalling between stages.\nDesign Implementation The first guideline is straightforward to implement: the dwn_data signal is latched onto up_data only when the dwn_valid and up_rdy signals are both high. This ensures that data transfer occurs only under the right conditions, maintaining synchronization and avoiding potential issues like overwrites or invalid data propagation.\nalways_ff@(posedge clk)begin if(dwn_vld \u0026 up_rdy) up_data \u003c= dwn_data; end At first glance, the second guideline seems straightforward, but its implementation can be a bit tricky due to interactions with the third guideline. Let’s break it down:\nThe up_valid signal must stay asserted (high) until the up_rdy signal is asserted by the consumer. On the other hand, the dwn_valid signal can be deasserted once the data has been successfully latched onto the slice. This ensures compliance with the third guideline. always_ff@(posedge clk)begin if(rst) up_vld_reg \u003c= 1'b0; else begin if(dwn_vld \u0026 up_rdy) up_vld_reg \u003c= 1'b1; else if(up_vld \u0026 dwn_rdy) up_vld_reg \u003c= 1'b0; end end assign dwn_rdy = up_rdy; assign up_vld = up_vld_reg; The design appears to function seamlessly without any issues. But does it really? To truly understand its behavior, let’s dive deeper and examine the waveform below.\nFigure 3: Valid-ready Version 1\nThe waveform illustrates how dwn_vld and up_rdy signals are randomly asserted and deasserted over time. This randomness introduces an element of unpredictability that challenges the robustness of the design. Let’s analyze the behavior step-by-step and uncover whether the design holds up under these conditions.\nAt point a:\nThe signal up_rdy is asserted (set high), indicating that the upstream block is ready to read data. Data from the slice is read out since up_vld and up_rdy both are high. At point c:\nThe signal up_vld is low, indicating that no valid data is stored in the slice. At point b:\nThe downstream signal dwn_vld is asserted (set high), indicating the downstream block a valid data is available. But the dwn_rdy is not set high even though the slice does not hold any valid data. The implemented logic does not latches data at this point, leading to inefficiency in the handshake mechanism. At point d:\nThe upstream signal up_rdy is high again, signaling data is ready to be read out. Since there is no valid data available, nothing is read out, wasting this opportunity. At point e:\nA valid handshake finally occurs when both dwn_vld and up_rdy are high, and valid data is latched into the slice. This marks the point of successful data transfer but underscores the inefficiency leading up to it. Observation Inefficient Data Handling: Data failing to latch at b when there is no valid data present in the slice reduces the overall efficiency of the valid-ready mechanism. Delayed Latching: The lack of synchronization between dwn_rdy and up_vld leads to unnecessary toggling and delays. Error-Prone Design: The logic, as currently implemented, introduces inefficiencies that can compound in high-throughput systems as it cabe be seen in the comparison table. Updated Valid-Ready Implemenation The data fails to latch at b because dwn_rdy was not set high when there was no valid data stored in the slice. An additional logic must be added in the if statement to latch data when the data is read from the slice.\nDuring the analysis of the valid-ready handshake mechanism in the previous section, an intriguing issue arose. At point b, the data failed to latch. Why? The culprit was the dwn_rdy signal, which was not set high when no valid data was stored in the slice.\nThis behavior exposes a flaw in the previous logic. The absence of dwn_rdy prevents the system from latching data, even though it should. To resolve this, an additional condition must be incorporated into the if statement to ensure data is latched whenever it is read from the slice.\nalways_ff@(posedge clk)begin if(dwn_vld \u0026 (up_rdy | dwn_rdy)) up_data \u003c= dwn_data; end This ensure that the data is latch onto the slice when a dwn_vld is high and up_rdy or dwn_rdy is high. The next step is to carefully implement logic for dwn_rdy.\nTo enhance the functionality of the valid-ready handshake mechanism, additional logic has been implemented to ensure that data is reliably latched onto the slice. This happens when dwn_vld is high, accompanied by either up_rdy or dwn_rdy being high.\nWhile this improvement addresses the immediate data latching issue, the next critical step is to carefully design and implement the logic for dwn_rdy. This signal plays a pivotal role in ensuring that downstream readiness is accurately conveyed, enabling seamless data flow and improving overall system efficiency.\nalways_ff@(posedge clk, posedge rst)begin if(rst) up_vld_reg \u003c= 1'b0; else begin if(dwn_vld \u0026 (up_rdy | dwn_rdy)) up_vld_reg \u003c= 1'b1; else if(up_vld \u0026 dwn_rdy) up_vld_reg \u003c= 1'b0; end end assign dwn_rdy = up_rdy | ~up_vld_reg; assign up_vld = up_vld_reg; Let’s dive deeper into the enhanced implementation of the dwn_rdy condition and understand its advantages with a waveform example.\nFigure 4: Valid-Ready Version 2\nThe dwn_rdy signal is asserted high whenever up_rdy is high and up_vld_reg is low. This ensures the slice is immediately ready to accept new data after the current data is read out from the slice. Additionally, in the if statement, the dwn_rdy condition is checked to determine whether the slice contains valid data.\nThis design not only addresses inefficiencies in the earlier implementation but also optimizes data flow through the slice.\nAt point a:\nThe signal up_rdy is asserted, indicating that the upstream block is ready to read data. Since both up_vld and up_rdy are high, data from the slice is successfully read out. At point b:\nThe signal dwn_vld is high, indicating valid data is present at the slice. With the updated implementation, dwn_rdy is also set high, allowing data to be latched onto the slice and made available in the next clock cycle. At point c:\nThis point indicates the arrival of new valid data, as reflected by up_vld being set high. At point d:\nThe up_rdy signal is high, and valid data is read out. After the data is read, up_vld is set low, but dwn_rdy is immediately asserted high, preparing the slice to receive the next set of data. At point e:\nNew data becomes available with up_vld set high, demonstrating a seamless transition to the next operation. These changes not only ensure smoother data transitions but also significantly enhance the overall reliability and performance of the system. By analyzing the waveform, it’s evident how these optimizations contribute to better performance and reliability in handshake logic systems.\nComparision Table To evaluate the efficiency of the valid-ready handshake protocol, simulations were conducted using Icarus Verilog. In these simulations, random values of dwn_vld and up_rdy were applied to compare the performance of two different design versions.\nTo quantify the improvements made in the handshake mechanism, a performance comparison was conducted between Version 1 and Version 2. The table below summarizes the results, showing the total number of transactions completed by each version over varying numbers of clock cycles.\nNo. of Clock Cycles Total No. of Transactions in Version 1 Total No. of Transactions in Version 2 Difference 16 57 59 2 32 63 66 3 64 80 92 12 128 117 138 21 The results highlight a critical takeaway: over time version 2 leads to significantly improved performance where the total number of transaction in a given time increases, making it the superior choice for systems requiring high transaction throughput and the correct implementation of valid-ready protocol.\nWhile the valid-ready protocol might seem straightforward at first glance, its implementation demands meticulous analysis. If not carefully designed, the protocol can introduce subtle bugs and inefficiencies, potentially compromising system performance.\n",
  "wordCount" : "1607",
  "inLanguage": "en",
  "datePublished": "2024-11-29T18:17:00-05:00",
  "dateModified": "2024-11-29T18:17:00-05:00",
  "author":[{
    "@type": "Person",
    "name": "Kiran"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://24x7fpga.com/rtl_directory/2024_11_29_18_17_10_valid_ready_protocol/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://24x7fpga.com/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="/css/syntax.css" !important>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://24x7fpga.com/" accesskey="h" title="Home (Alt + H)">Home</a>
            
            
            <div class="vertical-line" style="height: 20px;"></div>
            
            
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://24x7fpga.com/rtl_directory/2024_06_05_00_21_53_rtl_design_directory" title="rtl">
                    <span> 


                           
                        
                         
                        rtl</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/sv_directory/2024_06_27_16_53_00_sv_verification_directory" title="sv">
                    <span> 


                           
                        
                         
                        sv</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/uvm_directory/2024_08_28_12_39_50_uvm_framework_directory" title="uvm">
                    <span> 


                           
                        
                         
                        uvm</span>  
                </a>
            </li>
            <li>
                <a href="https://24x7fpga.com/tags/" title="">
                    <span> 


                           
                        
                            
                    
                    
                    

                    
                    
                    

                    
                    
                    
                    


                    
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    
                    
                
                         
                        
                        <div style="text-decoration: none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 15"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="text-decoration: none">
                            <path d="M21 18V6H8L2 12L8 18H21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 12C12 13.1046 11.1046 14 10 14C8.89543 14 8 13.1046 8 12C8 10.8954 8.89543 10 10 10C11.1046 10 12 10.8954 12 12Z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="7" y1="7" x2="7" y2="7"></line>
                        </svg> 
                        </div>
                        </span>  
                </a>
            </li>
        </ul>
    </nav>
</header>







<script src="https://24x7fpga.com/js/mathjax-config.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Valid-Ready Protocol
    </h1>
    <div class="post-meta"><span title='2024-11-29 18:17:00 -0500 EST'>November 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1607 words&nbsp;·&nbsp;Kiran

</div>
  </header> 
  <div class="post-content"><p><a href="https://github.com/24x7fpga/RTL/tree/master/rtl_designs/valid_ready">Source</a> &ndash; <a href="/rtl_directory/2024_06_05_00_21_53_rtl_design_directory/">RTL Design Directory</a></p>
<p>The <strong>valid-ready</strong> protocol is a fundamental handshake mechanism in digital design, commonly used in protocols like AXI. It ensures smooth data flow between a producer (the data source) and a consumer (the data sink), enabling reliable and synchronized communication in hardware systems.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/valid_ready.svg"
         alt="Figure 1: Valid-Ready Flow Control" width="600px"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->Valid-Ready Flow Control</p>
        </figcaption>
</figure>

<h2 id="guidelines">Guidelines<a hidden class="anchor" aria-hidden="true" href="#guidelines">#</a></h2>
<p>The valid and ready signals are integral to many handshaking protocols, ensuring reliable data transfer between components in a digital system. Let’s break down their behavior:</p>
<ol>
<li>
<p>A data transfer occurs <strong>only when</strong> both the <code>valid</code> and <code>ready</code> signals are high simultaneously. This ensures that the producer has <code>valid data</code> to send and the consumer is ready to receive it.</p>
</li>
<li>
<p>The producer asserts the <code>valid</code> signal <strong>high</strong> whenever <code>valid data</code> is available for transfer. <strong>Importantly, the valid signal remains high until the transaction is complete</strong>.</p>
</li>
<li>
<p>The <code>valid</code> signal from the producer must be <strong>independent</strong> of the <code>ready</code> signal from the consumer. This design ensures that the producer can signal the availability of data without waiting for the consumer&rsquo;s readiness.</p>
</li>
</ol>
<h2 id="valid-ready-slice">Valid-Ready Slice<a hidden class="anchor" aria-hidden="true" href="#valid-ready-slice">#</a></h2>
<p>A valid-ready slice is a pipelined register or buffer that temporarily stores data that ensures that data flow in the data path improving timing and handling backpressure effectively.</p>
<p>A valid-ready slice is a critical component in digital design that enhances the reliability and efficiency of data transfer in a system. Simply put, it is a pipelined register or buffer that temporarily stores data in producer and consumer modules.</p>
<figure class="center !important">
    <img loading="lazy" src="/ox-hugo/valid_ready_slice.svg"
         alt="Figure 2: Valid-Ready Slice" width="550px"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->Valid-Ready Slice</p>
        </figcaption>
</figure>

<h3 id="key-benefits-of-valid-ready-slice">Key Benefits of Valid-Ready Slice<a hidden class="anchor" aria-hidden="true" href="#key-benefits-of-valid-ready-slice">#</a></h3>
<ol>
<li>
<p>Improved Timing: By introducing a pipelined stage, the valid-ready slice helps break down long combinational paths, ensuring the system meets timing requirements in high-speed designs.</p>
</li>
<li>
<p>Effective Backpressure Handling: In scenarios where the consumer cannot immediately process incoming data, the valid-ready slice manages the backpressure by regulating the valid and ready signals, preventing data loss or overwrites.</p>
</li>
<li>
<p>Seamless Data Flow: The slice ensures smooth data transfer between producer and consumer modules, even when they operate at different speeds or in different clock domains.</p>
</li>
<li>
<p>Pipelined Data Processing: In a processing pipeline, a slice ensures smooth data flow without overwriting or stalling between stages.</p>
</li>
</ol>
<h2 id="design-implementation">Design Implementation<a hidden class="anchor" aria-hidden="true" href="#design-implementation">#</a></h2>
<p>The first guideline is straightforward to implement: the <code>dwn_data</code> signal is latched onto <code>up_data</code> only when the <code>dwn_valid</code> and <code>up_rdy</code> signals are both high. This ensures that data transfer occurs only under the right conditions, maintaining synchronization and avoiding potential issues like overwrites or invalid data propagation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span>@(<span style="color:#66d9ef">posedge</span> clk)<span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span>(dwn_vld <span style="color:#f92672">&amp;</span> up_rdy)
</span></span><span style="display:flex;"><span>     up_data <span style="color:#f92672">&lt;=</span> dwn_data;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>At first glance, the second guideline seems straightforward, but its implementation can be a bit tricky due to interactions with the third guideline. Let’s break it down:</p>
<ul>
<li>The <code>up_valid</code> signal must stay asserted (high) until the <code>up_rdy</code> signal is asserted by the consumer.</li>
<li>On the other hand, the <code>dwn_valid</code> signal can be deasserted once the data has been successfully latched onto the slice. This ensures compliance with the third guideline.</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span>@(<span style="color:#66d9ef">posedge</span> clk)<span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span>(rst)
</span></span><span style="display:flex;"><span>      up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(dwn_vld <span style="color:#f92672">&amp;</span> up_rdy)
</span></span><span style="display:flex;"><span>             up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(up_vld <span style="color:#f92672">&amp;</span> dwn_rdy)
</span></span><span style="display:flex;"><span>             up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> dwn_rdy <span style="color:#f92672">=</span> up_rdy;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> up_vld  <span style="color:#f92672">=</span> up_vld_reg;
</span></span></code></pre></div><p>The design appears to function seamlessly without any issues. <strong>But does it really?</strong> To truly understand its behavior, let’s dive deeper and examine the waveform below.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/var1.svg"
         alt="Figure 3: Valid-ready Version 1"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 3: <!-- raw HTML omitted -->Valid-ready Version 1</p>
        </figcaption>
</figure>

<p>The waveform illustrates how <code>dwn_vld</code> and <code>up_rdy</code> signals are randomly asserted and deasserted over time. This randomness introduces an element of unpredictability that challenges the robustness of the design. Let’s analyze the behavior step-by-step and uncover whether the design holds up under these conditions.</p>
<ul>
<li>
<p>At point <strong>a</strong>:</p>
<ul>
<li>The signal <code>up_rdy</code> is asserted (set high), indicating that the upstream block is ready to read data.</li>
<li>Data from the slice is read out since <code>up_vld</code> and <code>up_rdy</code> both are high.</li>
</ul>
</li>
<li>
<p>At point <strong>c</strong>:</p>
<ul>
<li>The signal <code>up_vld</code> is low, indicating that no valid data is stored in the slice.</li>
</ul>
</li>
<li>
<p>At point <strong>b</strong>:</p>
<ul>
<li>The downstream signal <code>dwn_vld</code> is asserted (set high), indicating the downstream block a valid data is available.</li>
<li>But the <code>dwn_rdy</code> is not set high even though the slice does not hold any valid data.</li>
<li>The implemented logic does not latches data at this point, leading to inefficiency in the handshake mechanism.</li>
</ul>
</li>
<li>
<p>At point <strong>d</strong>:</p>
<ul>
<li>The upstream signal <code>up_rdy</code> is high again, signaling data is ready to be read out.</li>
<li>Since there is no valid data available, nothing is read out, wasting this opportunity.</li>
</ul>
</li>
<li>
<p>At point <strong>e</strong>:</p>
<ul>
<li>A valid handshake finally occurs when both <code>dwn_vld</code> and <code>up_rdy</code> are high, and valid data is latched into the slice.</li>
<li>This marks the point of successful data transfer but underscores the inefficiency leading up to it.</li>
</ul>
</li>
</ul>
<h3 id="observation">Observation<a hidden class="anchor" aria-hidden="true" href="#observation">#</a></h3>
<ul>
<li>Inefficient Data Handling: Data failing to latch at <strong>b</strong> when there is no valid data present in the slice reduces the overall efficiency of the valid-ready mechanism.</li>
<li>Delayed Latching: The lack of synchronization between <code>dwn_rdy</code> and <code>up_vld</code> leads to unnecessary toggling and delays.</li>
<li>Error-Prone Design: The logic, as currently implemented, introduces inefficiencies that can compound in high-throughput systems as it cabe be seen in the comparison table.</li>
</ul>
<h2 id="updated-valid-ready-implemenation">Updated Valid-Ready Implemenation<a hidden class="anchor" aria-hidden="true" href="#updated-valid-ready-implemenation">#</a></h2>
<p>The data fails to latch at <strong>b</strong> because <code>dwn_rdy</code> was not set high when there was no valid data stored in the slice. An additional logic must be added in the if statement to latch data when the data is read from the slice.</p>
<p>During the analysis of the valid-ready handshake mechanism in the previous section, an intriguing issue arose. At point <strong>b</strong>, the data failed to latch. <strong>Why?</strong> The culprit was the <code>dwn_rdy</code> signal, which was not set high when no valid data was stored in the slice.</p>
<p>This behavior exposes a flaw in the previous logic. The absence of <code>dwn_rdy</code> prevents the system from latching data, even though it should. To resolve this, an additional condition must be incorporated into the <strong>if statement</strong> to ensure data is latched whenever it is read from the slice.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span>@(<span style="color:#66d9ef">posedge</span> clk)<span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(dwn_vld <span style="color:#f92672">&amp;</span> (up_rdy <span style="color:#f92672">|</span> dwn_rdy))
</span></span><span style="display:flex;"><span>    up_data <span style="color:#f92672">&lt;=</span> dwn_data;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This ensure that the data is latch onto the slice when a <code>dwn_vld</code> is high and <code>up_rdy</code> or <code>dwn_rdy</code> is high. The next step is to carefully implement logic for <code>dwn_rdy</code>.</p>
<p>To enhance the functionality of the valid-ready handshake mechanism, additional logic has been implemented to ensure that data is reliably latched onto the slice. This happens when <code>dwn_vld</code> is high, accompanied by either <code>up_rdy</code> or <code>dwn_rdy</code> being high.</p>
<p>While this improvement addresses the immediate data latching issue, the next critical step is to carefully design and implement the logic for <code>dwn_rdy</code>. This signal plays a pivotal role in ensuring that downstream readiness is accurately conveyed, enabling seamless data flow and improving overall system efficiency.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span>@(<span style="color:#66d9ef">posedge</span> clk, <span style="color:#66d9ef">posedge</span> rst)<span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span>(rst)
</span></span><span style="display:flex;"><span>     up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(dwn_vld <span style="color:#f92672">&amp;</span> (up_rdy <span style="color:#f92672">|</span> dwn_rdy))
</span></span><span style="display:flex;"><span>              up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(up_vld <span style="color:#f92672">&amp;</span> dwn_rdy)
</span></span><span style="display:flex;"><span>              up_vld_reg <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> dwn_rdy <span style="color:#f92672">=</span> up_rdy <span style="color:#f92672">|</span> <span style="color:#f92672">~</span>up_vld_reg;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assign</span> up_vld  <span style="color:#f92672">=</span> up_vld_reg;
</span></span></code></pre></div><p>Let’s dive deeper into the enhanced implementation of the <code>dwn_rdy</code> condition and understand its advantages with a waveform example.</p>
<figure>
    <img loading="lazy" src="/ox-hugo/var2.svg"
         alt="Figure 4: Valid-Ready Version 2"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 4: <!-- raw HTML omitted -->Valid-Ready Version 2</p>
        </figcaption>
</figure>

<p>The <code>dwn_rdy</code> signal is asserted high whenever <code>up_rdy</code> is high and <code>up_vld_reg</code> is low. This ensures the slice is immediately ready to accept new data after the current data is read out from the slice. Additionally, in the <strong>if statement</strong>, the <code>dwn_rdy</code> condition is checked to determine whether the slice contains valid data.</p>
<p>This design not only addresses inefficiencies in the earlier implementation but also optimizes data flow through the slice.</p>
<ul>
<li>
<p>At point <strong>a</strong>:</p>
<ul>
<li>The signal <code>up_rdy</code> is asserted, indicating that the upstream block is ready to read data.</li>
<li>Since both <code>up_vld</code> and <code>up_rdy</code> are high, data from the slice is successfully read out.</li>
</ul>
</li>
<li>
<p>At point <strong>b</strong>:</p>
<ul>
<li>The signal <code>dwn_vld</code> is high, indicating valid data is present at the slice.</li>
<li>With the updated implementation, <code>dwn_rdy</code> is also set high, allowing data to be latched onto the slice and made available in the next clock cycle.</li>
</ul>
</li>
<li>
<p>At point <strong>c</strong>:</p>
<ul>
<li>This point indicates the arrival of new valid data, as reflected by <code>up_vld</code> being set high.</li>
</ul>
</li>
<li>
<p>At point <strong>d</strong>:</p>
<ul>
<li>The <code>up_rdy</code> signal is high, and valid data is read out.</li>
<li>After the data is read, <code>up_vld</code> is set low, but <code>dwn_rdy</code> is immediately asserted high, preparing the slice to receive the next set of data.</li>
</ul>
</li>
<li>
<p>At point <strong>e</strong>:</p>
<ul>
<li>New data becomes available with <code>up_vld</code> set high, demonstrating a seamless transition to the next operation.</li>
</ul>
</li>
</ul>
<p>These changes not only ensure smoother data transitions but also significantly enhance the overall reliability and performance of the system. By analyzing the waveform, it’s evident how these optimizations contribute to better performance and reliability in handshake logic systems.</p>
<h2 id="comparision-table">Comparision Table<a hidden class="anchor" aria-hidden="true" href="#comparision-table">#</a></h2>
<p>To evaluate the efficiency of the valid-ready handshake protocol, simulations were conducted using Icarus Verilog. In these simulations, random values of dwn_vld and up_rdy were applied to compare the performance of two different design versions.</p>
<p>To quantify the improvements made in the handshake mechanism, a performance comparison was conducted between Version 1 and Version 2. The table below summarizes the results, showing the total number of transactions completed by each version over varying numbers of clock cycles.</p>
<table>
<thead>
<tr>
<th>No. of Clock Cycles</th>
<th>Total No. of Transactions in Version 1</th>
<th>Total No. of Transactions in Version 2</th>
<th>Difference</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>57</td>
<td>59</td>
<td>2</td>
</tr>
<tr>
<td>32</td>
<td>63</td>
<td>66</td>
<td>3</td>
</tr>
<tr>
<td>64</td>
<td>80</td>
<td>92</td>
<td>12</td>
</tr>
<tr>
<td>128</td>
<td>117</td>
<td>138</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>The results highlight a critical takeaway: over time version 2 leads to significantly improved performance where the total number of transaction in a given time increases, making it the superior choice for systems requiring high transaction throughput and the correct implementation of valid-ready protocol.</p>
<p>While the valid-ready protocol might seem straightforward at first glance, its implementation demands meticulous analysis. If not carefully designed, the protocol can introduce subtle bugs and inefficiencies, potentially compromising system performance.</p>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://24x7fpga.com/tags/rtl/">rtl</a></li>
    </ul>



    <div class="bottom-line" ></div>
    
    
    
      <img src="/img/org_mode.png" class="center" alt="footer" style="max-width:50px" />
    

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://24x7fpga.com/"></a></span>
        
        


</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><footer class="footer">

</footer>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
